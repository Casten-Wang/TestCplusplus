# 数据结构

[TOC]

## 参考资料

- [2022王道数据结构](file:///D:/为中华之崛起而读书/考研/王道/2022王道数据结构.pdf)
- [数据结构_中国大学MOOC](https://www.icourse163.org/learn/ZJU-93001?tid=1459700443#/learn/content)
- [数据结构与算法分析：C语言描述](file:///D:/为中华之崛起而读书/计算机书籍/算法和数据结构/数据结构与算法分析：C语言描述_原书第2版_高清版.pdf)
- [数据结构 陈越](file:///D:/为中华之崛起而读书/计算机书籍/算法和数据结构/数据结构  第2版__陈越_北京：高等教育出版社_P315_2016.06_14043535.pdf)

## 1. 线性表

## 2. 栈和队列

## 3. 串

## 4. 树

## 5. 图

### 5.1 图的基本概念

#### 5.1.1 定义

图 $G$ 由顶点集 $V$ 和边集 $E$ 组成，记为 $G=(V,E)$，其中 $V(G)$ 表示图 $G$ 中顶点的有限非空集；$E(G)$ 表示图 $G$ 中顶点之间的关系（边）集合。

#### 5.1.2 有向图

##### 概念

若 $E$ 是有向边（也称弧）的有限集合时，则图 $G$ 为有向图。弧是顶点的有序对，记为 $<v,w>$，其中 $v,w$ 是顶点， $v$ 称为弧尾，$w$ 称为弧头，$<v,w>$ 称为从 $v$ 到 $w$ 的弧，也称 $v$ 邻接到 $w$。

![image-20210717144505474](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210717144512.png)

![image-20210717144522684](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210717144522.png)

##### 模板

###### 邻接矩阵

```c
/* 
有向图邻接矩阵
*/

#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

#define MaxVertexNum 100
typedef int weightType;  // 权重数据类型
typedef char vertexType; // 顶点数据类型

struct Graph
{
    int vertexnum;
    int edgenum;
    vertexType vertexList[MaxVertexNum];
    weightType edgeList[MaxVertexNum][MaxVertexNum];
};

void BuildGraph(Graph *G)
{
    int start, end;
    cout << "Please enter the number of vertices and edges" << endl;
    cin >> G->vertexnum >> G->edgenum;
    // 图的权重初始化
    for (int i = 0; i < G->vertexnum; i++)
    {
        for (int j = 0; j < G->vertexnum; j++)
        {
            G->edgeList[i][j] = 0;
        }
    }
    // 图的顶点数据
    for (int i = 0; i < G->vertexnum; i++)
    {
        cout << "Please enter the data of vertex" << i + 1 << endl;
        cin >> G->vertexList[i];
    }
    // 输入权重信息
    for (int i = 0; i < G->edgenum; i++)
    {
        cout << "Please enter the Start number, end number, weight" << endl;
        cin >> start >> end;
        cin >> G->edgeList[start - 1][end - 1];
    }
    cout << endl;
}

void Print_Adjacency_Matrix(Graph G)
{
    for (int i = 0; i < G.vertexnum; i++)
    {
        for (int j = 0; j < G.vertexnum; j++)
        {
            cout << G.edgeList[i][j] << '\t';
        }
        cout << endl;
    }
}

int main()
{
    Graph G;
    BuildGraph(&G);
    Print_Adjacency_Matrix(G);
    cout << endl;
    system("pause");
    return 0;
}
```

###### 邻接表

![image-20210718172437170](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210718175002.png)

```c
/* 
有向图邻接表
*/

#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

#define MaxVertexNum 100
typedef int weightType;  // 权重数据类型
typedef char vertexType; // 顶点数据类型

struct EdgeNode
{
    int adjvex;
    weightType weight;
    EdgeNode *next;
};

struct VertexNode
{
    vertexType data;
    EdgeNode *firstedge;
};

struct Graph
{
    int vertexnum;
    int edgenum;
    VertexNode vertexList[MaxVertexNum];
    VertexNode inverseVertexList[MaxVertexNum];
};

void BuildGraph(Graph *G)
{
    int start, end, weight;
    EdgeNode *newnode;
    cout << "Please enter the number of vertices and edges" << endl;
    cin >> G->vertexnum >> G->edgenum;
    // 图的顶点数据
    for (int i = 0; i < G->vertexnum; i++)
    {
        cout << "Please enter the data of vertex" << i << endl;
        cin >> G->vertexList[i].data;
        G->vertexList[i].firstedge = NULL;
        G->inverseVertexList[i].data = G->vertexList[i].data;
        G->inverseVertexList[i].firstedge = NULL;
    }
    // 输入权重信息
    for (int i = 0; i < G->edgenum; i++)
    {
        cout << "Please enter the Start number, end number, weight" << endl;
        cin >> start >> end >> weight;
        //start-->end
        newnode = new EdgeNode;
        newnode->adjvex = end;
        newnode->weight = weight;
        newnode->next = G->vertexList[start].firstedge;
        G->vertexList[start].firstedge = newnode;
        // 逆邻接表
        newnode = new EdgeNode;
        newnode->adjvex = start;
        newnode->weight = weight;
        newnode->next = G->inverseVertexList[end].firstedge;
        G->inverseVertexList[end].firstedge = newnode;
    }
}

void Print_Adjacency_Matrix(Graph G)
{
    for (int i = 0; i < G.vertexnum; i++)
    {
        cout << G.vertexList[i].data << '\t';
        EdgeNode *p = G.vertexList[i].firstedge;
        while (p)
        {
            printf("adjvex:%d weight:%d  ", p->adjvex, p->weight);
            p = p->next;
        }
        cout << endl;
    }
    cout << endl;
    cout << "inverse adjacency list" << endl;
    for (int i = 0; i < G.vertexnum; i++)
    {
        cout << G.inverseVertexList[i].data << '\t';
        EdgeNode *p = G.inverseVertexList[i].firstedge;
        while (p)
        {
            printf("adjvex:%d weight:%d  ", p->adjvex, p->weight);
            p = p->next;
        }
        cout << endl;
    }
}

int main()
{
    Graph G;
    BuildGraph(&G);
    Print_Adjacency_Matrix(G);
    cout << endl;
    system("pause");
    return 0;
}
```



#### 5.1.3 无向图

##### 概念

若 $E$ 是无向边的有限集合时，则图 $G$ 为有向图。边是顶点的无序对，记为 $(v,w)$ 或 $(w,v)$。可以说 $w$ 和 $v$ $互为$邻接点。边 $(V,W)$ 依附于 $w$ $和v$，或称边 $(v,w)$ 和 $v,w$ 相关联。

![image-20210717145306226](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210717145306.png)

![image-20210717145319728](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210717145319.png)

##### 模板

###### 邻接矩阵

```c
/* 
无向图邻接矩阵
*/

#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

#define MaxVertexNum 100
typedef int weightType;  // 权重数据类型
typedef char vertexType; // 顶点数据类型

struct Graph
{
    int vertexnum;
    int edgenum;
    vertexType vertexList[MaxVertexNum];
    weightType edgeList[MaxVertexNum][MaxVertexNum];
};

void BuildGraph(Graph *G)
{
    int start, end;
    cout << "Please enter the number of vertices and edges" << endl;
    cin >> G->vertexnum >> G->edgenum;
    // 图的权重初始化
    for (int i = 0; i < G->vertexnum; i++)
    {
        for (int j = 0; j < G->vertexnum; j++)
        {
            G->edgeList[i][j] = 0;
        }
    }
    // 图的顶点数据
    for (int i = 0; i < G->vertexnum; i++)
    {
        cout << "Please enter the data of vertex" << i + 1 << endl;
        cin >> G->vertexList[i];
    }
    // 输入权重信息
    for (int i = 0; i < G->edgenum; i++)
    {
        cout << "Please enter the Start number, end number, weight" << endl;
        cin >> start >> end;
        cin >> G->edgeList[start - 1][end - 1];
        G->edgeList[end - 1][start - 1] = G->edgeList[start - 1][end - 1];
    }
    cout << endl;
}

void Print_Adjacency_Matrix(Graph G)
{
    cout << '\t';
    for (int i = 0; i < G.vertexnum; i++)
    {
        cout << G.vertexList[i] << '\t';
    }
    cout << endl;
    for (int i = 0; i < G.vertexnum; i++)
    {
        cout << G.vertexList[i] << '\t';
        for (int j = 0; j < G.vertexnum; j++)
        {
            cout << G.edgeList[i][j] << '\t';
        }
        cout << endl;
    }
}

int main()
{
    Graph G;
    BuildGraph(&G);
    Print_Adjacency_Matrix(G);
    cout << endl;
    system("pause");
    return 0;
}
```

###### 邻接表

![image-20210718145812980](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210718145820.png)

```c
/* 
无向图邻接表
*/

#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

#define MaxVertexNum 100
typedef int weightType;  // 权重数据类型
typedef char vertexType; // 顶点数据类型

struct EdgeNode
{
    int adjvex;
    weightType weight;
    EdgeNode *next;
};

struct VertexNode
{
    vertexType data;
    EdgeNode *firstedge;
};

struct Graph
{
    int vertexnum;
    int edgenum;
    VertexNode vertexList[MaxVertexNum];
};

void BuildGraph(Graph *G)
{
    int start, end, weight;
    EdgeNode *newnode;
    cout << "Please enter the number of vertices and edges" << endl;
    cin >> G->vertexnum >> G->edgenum;
    // 图的顶点数据
    for (int i = 0; i < G->vertexnum; i++)
    {
        cout << "Please enter the data of vertex" << i << endl;
        cin >> G->vertexList[i].data;
        G->vertexList[i].firstedge = NULL;
    }
    // 输入权重信息
    for (int i = 0; i < G->edgenum; i++)
    {
        cout << "Please enter the Start number, end number, weight" << endl;
        cin >> start >> end >> weight;
        //start-->end
        newnode = new EdgeNode;
        newnode->adjvex = end;
        newnode->weight = weight;
        newnode->next = G->vertexList[start].firstedge;
        G->vertexList[start].firstedge = newnode;
        // end-->start
        newnode = new EdgeNode;
        newnode->adjvex = start;
        newnode->weight = weight;
        newnode->next = G->vertexList[end].firstedge;
        G->vertexList[end].firstedge = newnode;
    }
}

void Print_Adjacency_Matrix(Graph G)
{
    for (int i = 0; i < G.vertexnum; i++)
    {
        cout << G.vertexList[i].data << '\t';
        EdgeNode *p = G.vertexList[i].firstedge;
        while (p)
        {
            printf("adjvex:%d weight:%d\n", p->adjvex, p->weight);
            p = p->next;
        }
        cout << endl;
    }
}

int main()
{
    Graph G;
    BuildGraph(&G);
    Print_Adjacency_Matrix(G);
    cout << endl;
    system("pause");
    return 0;
}
```



#### 5.1.4 简单图

1. 不存在重复边
2. 不存在顶点到自身的边

#### 5.1.5 完全图

- 对于无向图

$\vert{E}\vert$ 的取值范围 $0$ 到 $n(n-1)/2$，有 $n(n-1)/2$ 条边的无向图称为完全图

- 对于有向图

$\vert{E}\vert$ 的取值范围 $0$ 到 $n(n-1)$，有 $n(n-1)$ 条弧的有向图称为有向完全图

### 5.2 图的遍历

#### 5.2.1 广度优先搜索

##### 概念

广度优先搜索（也称宽度优先搜索，缩写BFS）是连通图的一种遍历算法这一算法也是很多重要的图的算法的原型。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。基本过程，BFS是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。一般用队列数据结构来辅助实现BFS算法。

##### 基本步骤

1. 给出一连通图，如图，初始化全是白色（未访问）；

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120715.webp)

2. 搜索起点V1（灰色）；

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120708.webp)

3. 已搜索V1（黑色），即将搜索V2，V3，V4（标灰）；

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120706.webp)

4. 对V2，V3，V4重复以上操作；

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120704.webp)

5. 直到终点V7被染灰，终止；

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120702.webp)

##### 模板

```c
/* 
通过邻接矩阵实现BFS
*/

#include <iostream>
#include <queue>
using namespace std;

#define MaxVertexNum 10

struct Graph
{
    int vertexnum;
    int edgenum;
    bool visit[MaxVertexNum];
    int edgeList[MaxVertexNum][MaxVertexNum];
};

void BuildGraph(Graph *G)
{
    int start, end;
    cout << "Please enter the number of vertices and edges" << endl;
    cin >> G->vertexnum >> G->edgenum;
    // 图的权重初始化
    for (int i = 0; i < G->vertexnum; i++)
    {
        G->visit[i] = false;
        for (int j = 0; j < G->vertexnum; j++)
        {
            G->edgeList[i][j] = 0;
        }
    }
    // 输入权重信息
    for (int i = 0; i < G->edgenum; i++)
    {
        cout << "Please enter the Start number, end number, weight" << endl;
        cin >> start >> end;
        cin >> G->edgeList[start][end];
        G->edgeList[end][start] = G->edgeList[start][end];
    }
    cout << endl;
}

void BFS(Graph *G)
{
    queue<int> q;
    G->visit[0] = true;
    q.push(0);
    while (!q.empty())
    {
        int tmp = q.front();
        q.pop();
        for (int i = 0; i < G->vertexnum; i++)
        {
            if (G->edgeList[tmp][i] && !G->visit[i])
            {
                G->visit[i] = true;
                q.push(i);
                cout << i << "Visited" << endl;
            }
        }
    }
}

int main()
{
    Graph G;
    BuildGraph(&G);
    BFS(&G);
    cout << endl;
    system("pause");
    return 0;
}

/* 
7 9
0 2 1
0 1 1
0 3 1
1 2 1
2 3 1
2 4 1
3 6 1
1 5 1
5 6 1
*/
```

##### 总结

广度优先搜索就是访问根结点相邻的所有结点，同时相邻的结点被访问后进入队列，然后依次出队，访问所有未访问结点。类似与水波一圈一圈荡开的结构。

#### 5.2.2 深度优先搜索

##### 概念

深度优先搜索属于图算法的一种，是一个针对图和树的遍历算法。深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。

##### 基本步骤

1. 对于下面的树而言，DFS方法首先从根节点1开始

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120508.webp)

2. 从stack中访问栈顶的点；

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120505.webp)

3. 找出与此点邻接的且尚未遍历的点，进行标记，然后放入stack中，依次进行；

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120501.webp)

4. 如果此点没有尚未遍历的邻接点，则将此点从stack中弹出，再按照（3）依次进行；

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120449.webp)

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120446.webp)

5. 直到遍历完整个树，stack里的元素都将弹出，最后栈为空，DFS遍历完成。

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120444.webp)

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120440.webp)

##### 模板

```c
/* 
通过邻接表实现DFS
*/

#include <iostream>
#include <stack>
using namespace std;

#define MaxVertexNum 10

struct EdgeNode
{
    int adjvex;
    EdgeNode *next;
};

struct VertexNode
{
    EdgeNode *firstedge;
};

struct Graph
{
    int vertexnum;
    int edgenum;
    VertexNode vertexList[MaxVertexNum];
    bool visit[MaxVertexNum];
};

void BuildGraph(Graph *G)
{
    int start, end, weight;
    EdgeNode *newnode;
    cout << "Please enter the number of vertices and edges" << endl;
    cin >> G->vertexnum >> G->edgenum;
    // 图的顶点数据
    for (int i = 0; i < G->vertexnum; i++)
    {
        G->vertexList[i].firstedge = NULL;
        G->visit[i] = false;
    }
    // 输入权重信息
    for (int i = 0; i < G->edgenum; i++)
    {
        cout << "Please enter the Start number, end number" << endl;
        cin >> start >> end;
        //start-->end
        newnode = new EdgeNode;
        newnode->adjvex = end;
        newnode->next = G->vertexList[start].firstedge;
        G->vertexList[start].firstedge = newnode;
        // end-->start
        newnode = new EdgeNode;
        newnode->adjvex = start;
        newnode->next = G->vertexList[end].firstedge;
        G->vertexList[end].firstedge = newnode;
    }
}

void Print_Adjacency_Matrix(Graph G)
{
    for (int i = 0; i < G.vertexnum; i++)
    {
        cout << i << '\t';
        EdgeNode *p = G.vertexList[i].firstedge;
        while (p)
        {
            printf("adjvex:%d  ", p->adjvex);
            p = p->next;
        }
        cout << endl;
    }
}

void DFS(Graph *G)
{
    stack<int> s;
    s.push(0);
    G->visit[0] = true;
    while (!s.empty())
    {
        int tmp = s.top();
        EdgeNode *p = G->vertexList[tmp].firstedge;
        while (p)
        {
            if (G->visit[p->adjvex])
            {
                p = p->next;
            }
            else
            {
                cout << "-->" << p->adjvex;
                s.push(p->adjvex);
                G->visit[p->adjvex] = true;
                // 找到下一深度的点就不再周边广搜
                break;
            }
            // 周围没有待访问的点，出栈
            if (p == NULL)
            {
                s.pop();
            }
        }
    }
}

int main()
{
    Graph G;
    BuildGraph(&G);
    Print_Adjacency_Matrix(G);
    DFS(&G);
    cout << endl;
    system("pause");
    return 0;
}

/*  
9 10
0 1
0 7
1 2
1 4
7 5 
7 8
2 3
4 3
5 3
5 6
*/
```

##### 总结

深度优先搜索就是一条道走到黑，然后到==无路可走==的时候回头。所以说最后会==回溯==所有的点。

### 5.3 最短路径问题

#### 5.3.1 Dijkstra算法

##### 概念

迪杰斯特拉算法，常用于==有权图==的==单源最短路径==问题，即求图中某一顶点到其他各顶点的最短路径。

![image-20210720143332122](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210720143339.png)

##### 模板

```c
/*  
有权图的单源最短路径问题
*/

#include <iostream>
#include <queue>
using namespace std;

#define MaxVertexNum 10

struct Node
{
    int vertex;
    int dist;
};

struct Graph
{
    int edgenum;
    int vertexnum;
    int edgeList[MaxVertexNum][MaxVertexNum];
    bool visit[MaxVertexNum];
    int path[MaxVertexNum]; // 前驱结点
    int dist[MaxVertexNum]; // 从源点到其他各顶点当前最短路径长度
};

class mycomparison
{
public:
    bool operator()(const Node &a, Node &b)
    {
        return a.dist > b.dist;
    }
};

void BuildGraph(Graph *G)
{
    int start, end;
    cout << "Please enter the number of vertices and edges" << endl;
    cin >> G->vertexnum >> G->edgenum;
    // 图的权重初始化
    for (int i = 1; i <= G->vertexnum; i++)
    {
        G->visit[i] = false;
        G->path[i] = -1;
        G->dist[i] = INT_MAX;
        for (int j = 1; j <= G->vertexnum; j++)
        {
            G->edgeList[i][j] = 0;
        }
    }
    // 输入权重信息
    for (int i = 1; i <= G->edgenum; i++)
    {
        cout << "Please enter the Start number, end number, weight" << endl;
        cin >> start >> end;
        cin >> G->edgeList[start][end];
    }
    cout << endl;
}

void Dijkstra(Graph *G, int v)
{
    // 初始化
    G->visit[v] = true;
    G->dist[v] = 0;
    priority_queue<Node, vector<Node>, mycomparison> minheap;
    Node p;
    for (int i = 1; i <= G->vertexnum; i++)
    {
        if (G->edgeList[v][i])
        {
            G->dist[i] = G->edgeList[v][i];
            G->path[i] = v;
            p.dist = G->dist[i];
            p.vertex = i;
            minheap.push(p);
        }
    }
    while (!minheap.empty())
    {
        // 选出未访问顶点中dist最小的
        int minv = minheap.top().vertex;
        minheap.pop();
        G->visit[minv] = true;
        for (int i = 1; i <= G->vertexnum; i++)
        {
            if (G->edgeList[minv][i] && !G->visit[i] && G->dist[minv] + G->edgeList[minv][i] < G->dist[i])
            {
                G->dist[i] = G->dist[minv] + G->edgeList[minv][i];
                G->path[i] = minv;
                p.dist = G->dist[i];
                p.vertex = i;
                minheap.push(p);
            }
        }
    }
    cout << endl;
}

int main()
{
    Graph G;
    BuildGraph(&G);
    Dijkstra(&G, 1);
    cout << "distance" << endl;
    for (int i = 1; i <= G.vertexnum; i++)
    {
        cout << G.dist[i] << " ";
    }
    cout << endl;
    cout << "path" << endl;
    for (int i = 1; i <= G.vertexnum; i++)
    {
        cout << G.path[i] << " ";
    }
    system("pause");
    return 0;
}

/*  
7 12
1 2 2
1 4 1
2 4 3
2 5 10
4 5 2
4 3 2
3 1 4
3 6 5
4 6 8
4 7 4
5 7 6
7 6 1
*/
```

#### 5.3.2 Floyd算法

##### 概念

弗洛伊德算法，常用于==多源最短路径==问题，即求每对顶点间的最短路径。

![image-20210721120937277](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210721120944.png)

##### 模板

```c
/*  
有权图的多源最短路径问题
*/

#include <iostream>
#include <queue>
using namespace std;

#define MaxVertexNum 10
#define infinity 1e9
struct Graph
{
    int edgenum;
    int vertexnum;
    int edgeList[MaxVertexNum][MaxVertexNum];
    int path[MaxVertexNum][MaxVertexNum]; // 前驱结点
    int dist[MaxVertexNum][MaxVertexNum]; // 从源点到其他各顶点当前最短路径长度
};

void BuildGraph(Graph *G)
{
    int start, end;
    cout << "Please enter the number of vertices and edges" << endl;
    cin >> G->vertexnum >> G->edgenum;
    // 图的权重初始化
    for (int i = 1; i <= G->vertexnum; i++)
    {
        for (int j = 1; j <= G->vertexnum; j++)
        {
            if (i == j)
            {
                G->edgeList[i][j] = 0;
            }
            else
            {
                G->edgeList[i][j] = infinity;
            }
            G->dist[i][j] = G->edgeList[i][j];
            G->path[i][j] = -1;
        }
    }
    // 输入权重信息
    for (int i = 1; i <= G->edgenum; i++)
    {
        cout << "Please enter the Start number, end number, weight" << endl;
        cin >> start >> end;
        cin >> G->edgeList[start][end];
        G->dist[start][end] = G->edgeList[start][end];
    }
}

void Floyd(Graph *G)
{
    for (int k = 1; k <= G->vertexnum; k++)
    {
        for (int i = 1; i <= G->vertexnum; i++)
        {
            for (int j = 1; j <= G->vertexnum; j++)
            {
                if (G->dist[i][k] + G->dist[k][j] < G->dist[i][j])
                {
                    G->dist[i][j] = G->dist[i][k] + G->dist[k][j];
                    G->path[i][j] = k;
                }
            }
        }
    }
}

int main()
{
    Graph G;
    BuildGraph(&G);
    Floyd(&G);
    cout << "edge" << endl;
    for (int i = 1; i <= G.vertexnum; i++)
    {
        for (int j = 1; j <= G.vertexnum; j++)
        {
            if (G.edgeList[i][j] != infinity)
            {
                printf("%10d", G.edgeList[i][j]);
            }
            else
            {
                printf("%10s", "infinity");
            }
        }
        cout << endl;
    }
    cout << "distance" << endl;
    for (int i = 1; i <= G.vertexnum; i++)
    {
        for (int j = 1; j <= G.vertexnum; j++)
        {
            cout << G.dist[i][j] << " ";
        }
        cout << endl;
    }
    cout << "path" << endl;
    for (int i = 1; i <= G.vertexnum; i++)
    {
        for (int j = 1; j <= G.vertexnum; j++)
        {
            cout << G.path[i][j] << " ";
        }
        cout << endl;
    }
    system("pause");
    return 0;
}

/*  
4 8
1 4 4
4 1 5
4 3 12
3 4 1
1 3 6
3 1 7
1 2 2
2 3 3
*/
```

##### 想法

可以这么理解，将第一层循环的 `k` 看成是==中转点==，嵌套的2层循环里得到的 `i，j` 一对顶点，求的就是 `i` 到 `j` 的距离。判断从 `i` 出发经由 `k` 再到 `j` 的路径是否比当前储存的路径短，然后更新。

### 5.4 最小生成树

#### 5.4.1 定义

连通图的生成树包含图的==所有==顶点，并且边数为==顶点数减一==。对于生成树来说，若砍去它的一条边，则会使生成树变成非连通图；若给它增加一条边，则会形成图中的一条回路。

生成树不同，每棵树的权值之和也可能不同，权值之和最小的那棵生成树，就是最小生成树。

- $|V|$ 个顶点一定有 $|V|-1$​ 条边
- 无回路

#### 5.4.2 Prim算法

##### 概念

首先任取一个顶点加入树，之后选择一个与当前树中顶点集合距离最小的顶点，将他加入树。直至图中所有顶点都并入树，得到的就是最小生成树。

![image-20210722120712175](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210722120719.png)

##### 模板

```c
/*  
最小生成树 Prim算法
*/

#include <iostream>
using namespace std;

#define MaxVertexNum 10

struct Graph
{
    int edgenum;
    int vertexnum;
    int edgeList[MaxVertexNum][MaxVertexNum];
    int parent[MaxVertexNum]; // 树的父亲结点
    int dist[MaxVertexNum];   // 到树的距离
};

void BuildGraph(Graph *G)
{
    int start, end;
    cout << "Please enter the number of vertices and edges" << endl;
    cin >> G->vertexnum >> G->edgenum;
    // 图的权重初始化
    for (int i = 1; i <= G->vertexnum; i++)
    {
        G->parent[i] = -1;
        G->dist[i] = INT_MAX;
        for (int j = 1; j <= G->vertexnum; j++)
        {
            G->edgeList[i][j] = 0;
        }
    }
    // 输入权重信息
    for (int i = 1; i <= G->edgenum; i++)
    {
        cout << "Please enter the Start number, end number, weight" << endl;
        cin >> start >> end;
        cin >> G->edgeList[start][end];
        G->edgeList[end][start] = G->edgeList[start][end];
    }
    cout << endl;
}

void Prim(Graph *G)
{
    int firstvertex = 1;
    G->dist[firstvertex] = 0;
    for (int i = 1; i <= G->vertexnum; i++)
    {
        if (G->edgeList[firstvertex][i])
        {
            G->dist[i] = G->edgeList[firstvertex][i];
            G->parent[i] = firstvertex;
        }
    }
    while (true)
    {
        // 寻找不在树里的结点中离树的距离最短的
        int minvertex, mindist = INT_MAX;
        for (int i = 1; i <= G->vertexnum; i++)
        {
            if (G->dist[i] != 0 && G->dist[i] < mindist)
            {
                mindist = G->dist[i];
                minvertex = i;
            }
        }
        // 循环结束条件：都在树中
        if (mindist == INT_MAX)
        {
            break;
        }
        // 将找到的点放入树中
        G->dist[minvertex] = 0;
        cout << "-->" << minvertex;
        // 以minvertex为源点扩散更新dist
        for (int i = 1; i <= G->vertexnum; i++)
        {
            // 寻找源点的邻接点且不在树中
            if (G->dist[i] != 0 && G->edgeList[minvertex][i])
            {
                // 如果距离小于原来的dist，则更新
                if (G->edgeList[minvertex][i] < G->dist[i])
                {
                    G->dist[i] = G->edgeList[minvertex][i];
                    G->parent[i] = minvertex;
                }
            }
        }
    }
    cout << endl;
}

int main()
{
    Graph G;
    BuildGraph(&G);
    Prim(&G);
    cout << "distance" << endl;
    for (int i = 1; i <= G.vertexnum; i++)
    {
        cout << G.dist[i] << " ";
    }
    cout << endl;
    cout << "parent" << endl;
    for (int i = 1; i <= G.vertexnum; i++)
    {
        cout << G.parent[i] << " ";
    }
    system("pause");
    return 0;
}

/*  
6 10
1 2 6
1 4 5
1 3 1
2 3 5
3 4 5
3 5 6
3 6 4
5 6 6
2 5 3
4 6 2
*/
```

##### 复杂度

时间复杂度：$O(|V|^2)$，不依赖于 $|E|$​，因此适合求解==稠密图==的最小生成树。

#### 5.4.3 Kruskal算法

##### 概念

![image-20210722120712175](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210722211938.png)

##### 模板

```c

```

##### 复杂度



### 5.5 拓扑排序

## 6. 排序

## 7. 查找
