# 数据结构

## 参考资料

- [2022王道数据结构](file:///D:/为中华之崛起而读书/考研/王道/2022王道数据结构.pdf)
- [数据结构_中国大学MOOC](https://www.icourse163.org/learn/ZJU-93001?tid=1459700443#/learn/content)
- [数据结构与算法分析：C语言描述](file:///D:/为中华之崛起而读书/计算机书籍/算法和数据结构/数据结构与算法分析：C语言描述_原书第2版_高清版.pdf)
- [数据结构 陈越](file:///D:/为中华之崛起而读书/计算机书籍/算法和数据结构/数据结构  第2版__陈越_北京：高等教育出版社_P315_2016.06_14043535.pdf)

## 目录

[TOC]

## 1. 线性表

## 2. 栈和队列

## 3. 串

## 4. 树

### 4.1 堆

#### 4.1.1 定义
优先队列：取出元素的顺序是依照元素的优先级(关键字)大小，而不是元素进入队列的先后顺序，以完全二叉树的形式存储。

- 最大堆：最大元素存放在根结点，且其任一非根结点的值小于等于其双亲结点值
- 最小堆：最小元素存放在根结点，且其任一非根结点的值大于等于其双亲结点值



## 5. 图

### 5.1 图的基本概念

#### 5.1.1 定义

图 $G$ 由顶点集 $V$ 和边集 $E$ 组成，记为 $G=(V,E)$，其中 $V(G)$ 表示图 $G$ 中顶点的有限非空集；$E(G)$ 表示图 $G$ 中顶点之间的关系（边）集合。

#### 5.1.2 有向图

##### 概念

若 $E$ 是有向边（也称弧）的有限集合时，则图 $G$ 为有向图。弧是顶点的有序对，记为 $<v,w>$，其中 $v,w$ 是顶点， $v$ 称为弧尾，$w$ 称为弧头，$<v,w>$ 称为从 $v$ 到 $w$ 的弧，也称 $v$ 邻接到 $w$。

![image-20210717144505474](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210717144512.png)

![image-20210717144522684](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210717144522.png)

##### 模板

###### 邻接矩阵

```c
/* 
有向图邻接矩阵
*/

#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

#define MaxVertexNum 100
typedef int weightType;  // 权重数据类型
typedef char vertexType; // 顶点数据类型

struct Graph
{
    int vertexnum;
    int edgenum;
    vertexType vertexList[MaxVertexNum];
    weightType edgeList[MaxVertexNum][MaxVertexNum];
};

void BuildGraph(Graph *G)
{
    int start, end;
    cout << "Please enter the number of vertices and edges" << endl;
    cin >> G->vertexnum >> G->edgenum;
    // 图的权重初始化
    for (int i = 0; i < G->vertexnum; i++)
    {
        for (int j = 0; j < G->vertexnum; j++)
        {
            G->edgeList[i][j] = 0;
        }
    }
    // 图的顶点数据
    for (int i = 0; i < G->vertexnum; i++)
    {
        cout << "Please enter the data of vertex" << i + 1 << endl;
        cin >> G->vertexList[i];
    }
    // 输入权重信息
    for (int i = 0; i < G->edgenum; i++)
    {
        cout << "Please enter the Start number, end number, weight" << endl;
        cin >> start >> end;
        cin >> G->edgeList[start - 1][end - 1];
    }
    cout << endl;
}

void Print_Adjacency_Matrix(Graph G)
{
    for (int i = 0; i < G.vertexnum; i++)
    {
        for (int j = 0; j < G.vertexnum; j++)
        {
            cout << G.edgeList[i][j] << '\t';
        }
        cout << endl;
    }
}

int main()
{
    Graph G;
    BuildGraph(&G);
    Print_Adjacency_Matrix(G);
    cout << endl;
    system("pause");
    return 0;
}
```

###### 邻接表

![image-20210718172437170](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210718175002.png)

```c
/* 
有向图邻接表
*/

#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

#define MaxVertexNum 100
typedef int weightType;  // 权重数据类型
typedef char vertexType; // 顶点数据类型

struct EdgeNode
{
    int adjvex;
    weightType weight;
    EdgeNode *next;
};

struct VertexNode
{
    vertexType data;
    EdgeNode *firstedge;
};

struct Graph
{
    int vertexnum;
    int edgenum;
    VertexNode vertexList[MaxVertexNum];
    VertexNode inverseVertexList[MaxVertexNum];
};

void BuildGraph(Graph *G)
{
    int start, end, weight;
    EdgeNode *newnode;
    cout << "Please enter the number of vertices and edges" << endl;
    cin >> G->vertexnum >> G->edgenum;
    // 图的顶点数据
    for (int i = 0; i < G->vertexnum; i++)
    {
        cout << "Please enter the data of vertex" << i << endl;
        cin >> G->vertexList[i].data;
        G->vertexList[i].firstedge = NULL;
        G->inverseVertexList[i].data = G->vertexList[i].data;
        G->inverseVertexList[i].firstedge = NULL;
    }
    // 输入权重信息
    for (int i = 0; i < G->edgenum; i++)
    {
        cout << "Please enter the Start number, end number, weight" << endl;
        cin >> start >> end >> weight;
        //start-->end
        newnode = new EdgeNode;
        newnode->adjvex = end;
        newnode->weight = weight;
        newnode->next = G->vertexList[start].firstedge;
        G->vertexList[start].firstedge = newnode;
        // 逆邻接表
        newnode = new EdgeNode;
        newnode->adjvex = start;
        newnode->weight = weight;
        newnode->next = G->inverseVertexList[end].firstedge;
        G->inverseVertexList[end].firstedge = newnode;
    }
}

void Print_Adjacency_Matrix(Graph G)
{
    for (int i = 0; i < G.vertexnum; i++)
    {
        cout << G.vertexList[i].data << '\t';
        EdgeNode *p = G.vertexList[i].firstedge;
        while (p)
        {
            printf("adjvex:%d weight:%d  ", p->adjvex, p->weight);
            p = p->next;
        }
        cout << endl;
    }
    cout << endl;
    cout << "inverse adjacency list" << endl;
    for (int i = 0; i < G.vertexnum; i++)
    {
        cout << G.inverseVertexList[i].data << '\t';
        EdgeNode *p = G.inverseVertexList[i].firstedge;
        while (p)
        {
            printf("adjvex:%d weight:%d  ", p->adjvex, p->weight);
            p = p->next;
        }
        cout << endl;
    }
}

int main()
{
    Graph G;
    BuildGraph(&G);
    Print_Adjacency_Matrix(G);
    cout << endl;
    system("pause");
    return 0;
}
```



#### 5.1.3 无向图

##### 概念

若 $E$ 是无向边的有限集合时，则图 $G$ 为有向图。边是顶点的无序对，记为 $(v,w)$ 或 $(w,v)$。可以说 $w$ 和 $v$ $互为$邻接点。边 $(V,W)$ 依附于 $w$ $和v$，或称边 $(v,w)$ 和 $v,w$ 相关联。

![image-20210717145306226](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210717145306.png)

![image-20210717145319728](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210717145319.png)

##### 模板

###### 邻接矩阵

```c
/* 
无向图邻接矩阵
*/

#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

#define MaxVertexNum 100
typedef int weightType;  // 权重数据类型
typedef char vertexType; // 顶点数据类型

struct Graph
{
    int vertexnum;
    int edgenum;
    vertexType vertexList[MaxVertexNum];
    weightType edgeList[MaxVertexNum][MaxVertexNum];
};

void BuildGraph(Graph *G)
{
    int start, end;
    cout << "Please enter the number of vertices and edges" << endl;
    cin >> G->vertexnum >> G->edgenum;
    // 图的权重初始化
    for (int i = 0; i < G->vertexnum; i++)
    {
        for (int j = 0; j < G->vertexnum; j++)
        {
            G->edgeList[i][j] = 0;
        }
    }
    // 图的顶点数据
    for (int i = 0; i < G->vertexnum; i++)
    {
        cout << "Please enter the data of vertex" << i + 1 << endl;
        cin >> G->vertexList[i];
    }
    // 输入权重信息
    for (int i = 0; i < G->edgenum; i++)
    {
        cout << "Please enter the Start number, end number, weight" << endl;
        cin >> start >> end;
        cin >> G->edgeList[start - 1][end - 1];
        G->edgeList[end - 1][start - 1] = G->edgeList[start - 1][end - 1];
    }
    cout << endl;
}

void Print_Adjacency_Matrix(Graph G)
{
    cout << '\t';
    for (int i = 0; i < G.vertexnum; i++)
    {
        cout << G.vertexList[i] << '\t';
    }
    cout << endl;
    for (int i = 0; i < G.vertexnum; i++)
    {
        cout << G.vertexList[i] << '\t';
        for (int j = 0; j < G.vertexnum; j++)
        {
            cout << G.edgeList[i][j] << '\t';
        }
        cout << endl;
    }
}

int main()
{
    Graph G;
    BuildGraph(&G);
    Print_Adjacency_Matrix(G);
    cout << endl;
    system("pause");
    return 0;
}
```

###### 邻接表

![image-20210718145812980](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210718145820.png)

```c
/* 
无向图邻接表
*/

#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

#define MaxVertexNum 100
typedef int weightType;  // 权重数据类型
typedef char vertexType; // 顶点数据类型

struct EdgeNode
{
    int adjvex;
    weightType weight;
    EdgeNode *next;
};

struct VertexNode
{
    vertexType data;
    EdgeNode *firstedge;
};

struct Graph
{
    int vertexnum;
    int edgenum;
    VertexNode vertexList[MaxVertexNum];
};

void BuildGraph(Graph *G)
{
    int start, end, weight;
    EdgeNode *newnode;
    cout << "Please enter the number of vertices and edges" << endl;
    cin >> G->vertexnum >> G->edgenum;
    // 图的顶点数据
    for (int i = 0; i < G->vertexnum; i++)
    {
        cout << "Please enter the data of vertex" << i << endl;
        cin >> G->vertexList[i].data;
        G->vertexList[i].firstedge = NULL;
    }
    // 输入权重信息
    for (int i = 0; i < G->edgenum; i++)
    {
        cout << "Please enter the Start number, end number, weight" << endl;
        cin >> start >> end >> weight;
        //start-->end
        newnode = new EdgeNode;
        newnode->adjvex = end;
        newnode->weight = weight;
        newnode->next = G->vertexList[start].firstedge;
        G->vertexList[start].firstedge = newnode;
        // end-->start
        newnode = new EdgeNode;
        newnode->adjvex = start;
        newnode->weight = weight;
        newnode->next = G->vertexList[end].firstedge;
        G->vertexList[end].firstedge = newnode;
    }
}

void Print_Adjacency_Matrix(Graph G)
{
    for (int i = 0; i < G.vertexnum; i++)
    {
        cout << G.vertexList[i].data << '\t';
        EdgeNode *p = G.vertexList[i].firstedge;
        while (p)
        {
            printf("adjvex:%d weight:%d\n", p->adjvex, p->weight);
            p = p->next;
        }
        cout << endl;
    }
}

int main()
{
    Graph G;
    BuildGraph(&G);
    Print_Adjacency_Matrix(G);
    cout << endl;
    system("pause");
    return 0;
}
```



#### 5.1.4 简单图

1. 不存在重复边
2. 不存在顶点到自身的边

#### 5.1.5 完全图

- 对于无向图

$\vert{E}\vert$ 的取值范围 $0$ 到 $n(n-1)/2$，有 $n(n-1)/2$ 条边的无向图称为完全图

- 对于有向图

$\vert{E}\vert$ 的取值范围 $0$ 到 $n(n-1)$，有 $n(n-1)$ 条弧的有向图称为有向完全图

### 5.2 图的遍历

#### 5.2.1 广度优先搜索

##### 概念

广度优先搜索（也称宽度优先搜索，缩写BFS）是连通图的一种遍历算法这一算法也是很多重要的图的算法的原型。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。基本过程，BFS是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。一般用队列数据结构来辅助实现BFS算法。

##### 基本步骤

1. 给出一连通图，如图，初始化全是白色（未访问）；

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120715.webp)

2. 搜索起点V1（灰色）；

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120708.webp)

3. 已搜索V1（黑色），即将搜索V2，V3，V4（标灰）；

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120706.webp)

4. 对V2，V3，V4重复以上操作；

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120704.webp)

5. 直到终点V7被染灰，终止；

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120702.webp)

##### 模板

```c
/* 
通过邻接矩阵实现BFS
*/

#include <iostream>
#include <queue>
using namespace std;

#define MaxVertexNum 10

struct Graph
{
    int vertexnum;
    int edgenum;
    bool visit[MaxVertexNum];
    int edgeList[MaxVertexNum][MaxVertexNum];
};

void BuildGraph(Graph *G)
{
    int start, end;
    cout << "Please enter the number of vertices and edges" << endl;
    cin >> G->vertexnum >> G->edgenum;
    // 图的权重初始化
    for (int i = 0; i < G->vertexnum; i++)
    {
        G->visit[i] = false;
        for (int j = 0; j < G->vertexnum; j++)
        {
            G->edgeList[i][j] = 0;
        }
    }
    // 输入权重信息
    for (int i = 0; i < G->edgenum; i++)
    {
        cout << "Please enter the Start number, end number, weight" << endl;
        cin >> start >> end;
        cin >> G->edgeList[start][end];
        G->edgeList[end][start] = G->edgeList[start][end];
    }
    cout << endl;
}

void BFS(Graph *G)
{
    queue<int> q;
    G->visit[0] = true;
    q.push(0);
    while (!q.empty())
    {
        int tmp = q.front();
        q.pop();
        for (int i = 0; i < G->vertexnum; i++)
        {
            if (G->edgeList[tmp][i] && !G->visit[i])
            {
                G->visit[i] = true;
                q.push(i);
                cout << i << "Visited" << endl;
            }
        }
    }
}

int main()
{
    Graph G;
    BuildGraph(&G);
    BFS(&G);
    cout << endl;
    system("pause");
    return 0;
}

/* 
7 9
0 2 1
0 1 1
0 3 1
1 2 1
2 3 1
2 4 1
3 6 1
1 5 1
5 6 1
*/
```

##### 总结

广度优先搜索就是访问根结点相邻的所有结点，同时相邻的结点被访问后进入队列，然后依次出队，访问所有未访问结点。类似与水波一圈一圈荡开的结构。

#### 5.2.2 深度优先搜索

##### 概念

深度优先搜索属于图算法的一种，是一个针对图和树的遍历算法。深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。

##### 基本步骤

1. 对于下面的树而言，DFS方法首先从根节点1开始

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120508.webp)

2. 从stack中访问栈顶的点；

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120505.webp)

3. 找出与此点邻接的且尚未遍历的点，进行标记，然后放入stack中，依次进行；

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120501.webp)

4. 如果此点没有尚未遍历的邻接点，则将此点从stack中弹出，再按照（3）依次进行；

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120449.webp)

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120446.webp)

5. 直到遍历完整个树，stack里的元素都将弹出，最后栈为空，DFS遍历完成。

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120444.webp)

![](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210719120440.webp)

##### 模板

```c
/* 
通过邻接表实现DFS
*/

#include <iostream>
#include <stack>
using namespace std;

#define MaxVertexNum 10

struct EdgeNode
{
    int adjvex;
    EdgeNode *next;
};

struct VertexNode
{
    EdgeNode *firstedge;
};

struct Graph
{
    int vertexnum;
    int edgenum;
    VertexNode vertexList[MaxVertexNum];
    bool visit[MaxVertexNum];
};

void BuildGraph(Graph *G)
{
    int start, end, weight;
    EdgeNode *newnode;
    cout << "Please enter the number of vertices and edges" << endl;
    cin >> G->vertexnum >> G->edgenum;
    // 图的顶点数据
    for (int i = 0; i < G->vertexnum; i++)
    {
        G->vertexList[i].firstedge = NULL;
        G->visit[i] = false;
    }
    // 输入权重信息
    for (int i = 0; i < G->edgenum; i++)
    {
        cout << "Please enter the Start number, end number" << endl;
        cin >> start >> end;
        //start-->end
        newnode = new EdgeNode;
        newnode->adjvex = end;
        newnode->next = G->vertexList[start].firstedge;
        G->vertexList[start].firstedge = newnode;
        // end-->start
        newnode = new EdgeNode;
        newnode->adjvex = start;
        newnode->next = G->vertexList[end].firstedge;
        G->vertexList[end].firstedge = newnode;
    }
}

void Print_Adjacency_Matrix(Graph G)
{
    for (int i = 0; i < G.vertexnum; i++)
    {
        cout << i << '\t';
        EdgeNode *p = G.vertexList[i].firstedge;
        while (p)
        {
            printf("adjvex:%d  ", p->adjvex);
            p = p->next;
        }
        cout << endl;
    }
}

void DFS(Graph *G)
{
    stack<int> s;
    s.push(0);
    G->visit[0] = true;
    while (!s.empty())
    {
        int tmp = s.top();
        EdgeNode *p = G->vertexList[tmp].firstedge;
        while (p)
        {
            if (G->visit[p->adjvex])
            {
                p = p->next;
            }
            else
            {
                cout << "-->" << p->adjvex;
                s.push(p->adjvex);
                G->visit[p->adjvex] = true;
                // 找到下一深度的点就不再周边广搜
                break;
            }
            // 周围没有待访问的点，出栈
            if (p == NULL)
            {
                s.pop();
            }
        }
    }
}

int main()
{
    Graph G;
    BuildGraph(&G);
    Print_Adjacency_Matrix(G);
    DFS(&G);
    cout << endl;
    system("pause");
    return 0;
}

/*  
9 10
0 1
0 7
1 2
1 4
7 5 
7 8
2 3
4 3
5 3
5 6
*/
```

##### 总结

深度优先搜索就是一条道走到黑，然后到==无路可走==的时候回头。所以说最后会==回溯==所有的点。

### 5.3 最短路径问题

#### 5.3.1 Dijkstra算法

##### 概念

迪杰斯特拉算法，常用于==有权图==的==单源最短路径==问题，即求图中某一顶点到其他各顶点的最短路径。

![image-20210720143332122](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210720143339.png)

##### 模板

```c
/*  
有权图的单源最短路径问题
*/

#include <iostream>
#include <queue>
using namespace std;

#define MaxVertexNum 10

struct Node
{
    int vertex;
    int dist;
};

struct Graph
{
    int edgenum;
    int vertexnum;
    int edgeList[MaxVertexNum][MaxVertexNum];
    bool visit[MaxVertexNum];
    int path[MaxVertexNum]; // 前驱结点
    int dist[MaxVertexNum]; // 从源点到其他各顶点当前最短路径长度
};

class mycomparison
{
public:
    bool operator()(const Node &a, Node &b)
    {
        return a.dist > b.dist;
    }
};

void BuildGraph(Graph *G)
{
    int start, end;
    cout << "Please enter the number of vertices and edges" << endl;
    cin >> G->vertexnum >> G->edgenum;
    // 图的权重初始化
    for (int i = 1; i <= G->vertexnum; i++)
    {
        G->visit[i] = false;
        G->path[i] = -1;
        G->dist[i] = INT_MAX;
        for (int j = 1; j <= G->vertexnum; j++)
        {
            G->edgeList[i][j] = 0;
        }
    }
    // 输入权重信息
    for (int i = 1; i <= G->edgenum; i++)
    {
        cout << "Please enter the Start number, end number, weight" << endl;
        cin >> start >> end;
        cin >> G->edgeList[start][end];
    }
    cout << endl;
}

void Dijkstra(Graph *G, int v)
{
    // 初始化
    G->visit[v] = true;
    G->dist[v] = 0;
    priority_queue<Node, vector<Node>, mycomparison> minheap;
    Node p;
    for (int i = 1; i <= G->vertexnum; i++)
    {
        if (G->edgeList[v][i])
        {
            G->dist[i] = G->edgeList[v][i];
            G->path[i] = v;
            p.dist = G->dist[i];
            p.vertex = i;
            minheap.push(p);
        }
    }
    while (!minheap.empty())
    {
        // 选出未访问顶点中dist最小的
        int minv = minheap.top().vertex;
        minheap.pop();
        G->visit[minv] = true;
        for (int i = 1; i <= G->vertexnum; i++)
        {
            if (G->edgeList[minv][i] && !G->visit[i] && G->dist[minv] + G->edgeList[minv][i] < G->dist[i])
            {
                G->dist[i] = G->dist[minv] + G->edgeList[minv][i];
                G->path[i] = minv;
                p.dist = G->dist[i];
                p.vertex = i;
                minheap.push(p);
            }
        }
    }
    cout << endl;
}

int main()
{
    Graph G;
    BuildGraph(&G);
    Dijkstra(&G, 1);
    cout << "distance" << endl;
    for (int i = 1; i <= G.vertexnum; i++)
    {
        cout << G.dist[i] << " ";
    }
    cout << endl;
    cout << "path" << endl;
    for (int i = 1; i <= G.vertexnum; i++)
    {
        cout << G.path[i] << " ";
    }
    system("pause");
    return 0;
}

/*  
7 12
1 2 2
1 4 1
2 4 3
2 5 10
4 5 2
4 3 2
3 1 4
3 6 5
4 6 8
4 7 4
5 7 6
7 6 1
*/
```

#### 5.3.2 Floyd算法

##### 概念

弗洛伊德算法，常用于==多源最短路径==问题，即求每对顶点间的最短路径。

![image-20210721120937277](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210721120944.png)

##### 模板

```c
/*  
有权图的多源最短路径问题
*/

#include <iostream>
#include <queue>
using namespace std;

#define MaxVertexNum 10
#define infinity 1e9
struct Graph
{
    int edgenum;
    int vertexnum;
    int edgeList[MaxVertexNum][MaxVertexNum];
    int path[MaxVertexNum][MaxVertexNum]; // 前驱结点
    int dist[MaxVertexNum][MaxVertexNum]; // 从源点到其他各顶点当前最短路径长度
};

void BuildGraph(Graph *G)
{
    int start, end;
    cout << "Please enter the number of vertices and edges" << endl;
    cin >> G->vertexnum >> G->edgenum;
    // 图的权重初始化
    for (int i = 1; i <= G->vertexnum; i++)
    {
        for (int j = 1; j <= G->vertexnum; j++)
        {
            if (i == j)
            {
                G->edgeList[i][j] = 0;
            }
            else
            {
                G->edgeList[i][j] = infinity;
            }
            G->dist[i][j] = G->edgeList[i][j];
            G->path[i][j] = -1;
        }
    }
    // 输入权重信息
    for (int i = 1; i <= G->edgenum; i++)
    {
        cout << "Please enter the Start number, end number, weight" << endl;
        cin >> start >> end;
        cin >> G->edgeList[start][end];
        G->dist[start][end] = G->edgeList[start][end];
    }
}

void Floyd(Graph *G)
{
    for (int k = 1; k <= G->vertexnum; k++)
    {
        for (int i = 1; i <= G->vertexnum; i++)
        {
            for (int j = 1; j <= G->vertexnum; j++)
            {
                if (G->dist[i][k] + G->dist[k][j] < G->dist[i][j])
                {
                    G->dist[i][j] = G->dist[i][k] + G->dist[k][j];
                    G->path[i][j] = k;
                }
            }
        }
    }
}

int main()
{
    Graph G;
    BuildGraph(&G);
    Floyd(&G);
    cout << "edge" << endl;
    for (int i = 1; i <= G.vertexnum; i++)
    {
        for (int j = 1; j <= G.vertexnum; j++)
        {
            if (G.edgeList[i][j] != infinity)
            {
                printf("%10d", G.edgeList[i][j]);
            }
            else
            {
                printf("%10s", "infinity");
            }
        }
        cout << endl;
    }
    cout << "distance" << endl;
    for (int i = 1; i <= G.vertexnum; i++)
    {
        for (int j = 1; j <= G.vertexnum; j++)
        {
            cout << G.dist[i][j] << " ";
        }
        cout << endl;
    }
    cout << "path" << endl;
    for (int i = 1; i <= G.vertexnum; i++)
    {
        for (int j = 1; j <= G.vertexnum; j++)
        {
            cout << G.path[i][j] << " ";
        }
        cout << endl;
    }
    system("pause");
    return 0;
}

/*  
4 8
1 4 4
4 1 5
4 3 12
3 4 1
1 3 6
3 1 7
1 2 2
2 3 3
*/
```

##### 想法

可以这么理解，将第一层循环的 `k` 看成是==中转点==，嵌套的2层循环里得到的 `i，j` 一对顶点，求的就是 `i` 到 `j` 的距离。判断从 `i` 出发经由 `k` 再到 `j` 的路径是否比当前储存的路径短，然后更新。

### 5.4 最小生成树

#### 5.4.1 定义

连通图的生成树包含图的==所有==顶点，并且边数为==顶点数减一==。对于生成树来说，若砍去它的一条边，则会使生成树变成非连通图；若给它增加一条边，则会形成图中的一条回路。

生成树不同，每棵树的权值之和也可能不同，权值之和最小的那棵生成树，就是最小生成树。

- $|V|$ 个顶点一定有 $|V|-1$​ 条边
- 无回路

#### 5.4.2 Prim算法

##### 概念

首先任取一个顶点加入树，之后选择一个与当前树中顶点集合距离最小的顶点，将他加入树。直至图中所有顶点都并入树，得到的就是最小生成树。

![image-20210722120712175](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210722120719.png)

##### 模板

```c
/*  
最小生成树 Prim算法
*/

#include <iostream>
using namespace std;

#define MaxVertexNum 10

struct Graph
{
    int edgenum;
    int vertexnum;
    int edgeList[MaxVertexNum][MaxVertexNum];
    int parent[MaxVertexNum]; // 树的父亲结点
    int dist[MaxVertexNum];   // 到树的距离
};

void BuildGraph(Graph *G)
{
    int start, end;
    cout << "Please enter the number of vertices and edges" << endl;
    cin >> G->vertexnum >> G->edgenum;
    // 图的权重初始化
    for (int i = 1; i <= G->vertexnum; i++)
    {
        G->parent[i] = -1;
        G->dist[i] = INT_MAX;
        for (int j = 1; j <= G->vertexnum; j++)
        {
            G->edgeList[i][j] = 0;
        }
    }
    // 输入权重信息
    for (int i = 1; i <= G->edgenum; i++)
    {
        cout << "Please enter the Start number, end number, weight" << endl;
        cin >> start >> end;
        cin >> G->edgeList[start][end];
        G->edgeList[end][start] = G->edgeList[start][end];
    }
    cout << endl;
}

void Prim(Graph *G)
{
    int firstvertex = 1;
    G->dist[firstvertex] = 0;
    for (int i = 1; i <= G->vertexnum; i++)
    {
        if (G->edgeList[firstvertex][i])
        {
            G->dist[i] = G->edgeList[firstvertex][i];
            G->parent[i] = firstvertex;
        }
    }
    while (true)
    {
        // 寻找不在树里的结点中离树的距离最短的
        int minvertex, mindist = INT_MAX;
        for (int i = 1; i <= G->vertexnum; i++)
        {
            if (G->dist[i] != 0 && G->dist[i] < mindist)
            {
                mindist = G->dist[i];
                minvertex = i;
            }
        }
        // 循环结束条件：都在树中
        if (mindist == INT_MAX)
        {
            break;
        }
        // 将找到的点放入树中
        G->dist[minvertex] = 0;
        cout << "-->" << minvertex;
        // 以minvertex为源点扩散更新dist
        for (int i = 1; i <= G->vertexnum; i++)
        {
            // 寻找源点的邻接点且不在树中
            if (G->dist[i] != 0 && G->edgeList[minvertex][i])
            {
                // 如果距离小于原来的dist，则更新
                if (G->edgeList[minvertex][i] < G->dist[i])
                {
                    G->dist[i] = G->edgeList[minvertex][i];
                    G->parent[i] = minvertex;
                }
            }
        }
    }
    cout << endl;
}

int main()
{
    Graph G;
    BuildGraph(&G);
    Prim(&G);
    cout << "distance" << endl;
    for (int i = 1; i <= G.vertexnum; i++)
    {
        cout << G.dist[i] << " ";
    }
    cout << endl;
    cout << "parent" << endl;
    for (int i = 1; i <= G.vertexnum; i++)
    {
        cout << G.parent[i] << " ";
    }
    system("pause");
    return 0;
}

/*  
6 10
1 2 6
1 4 5
1 3 1
2 3 5
3 4 5
3 5 6
3 6 4
5 6 6
2 5 3
4 6 2
*/
```

##### 复杂度

时间复杂度：$O(|V|^2)$，不依赖于 $|E|$​，因此适合求解==稠密图==的最小生成树。

#### 5.4.3 Kruskal算法

##### 概念

将所有边通过最小堆排序。选择不会形成回路的边（通过并查集判断）插入树中，重复直至形成一棵树。

![image-20210722120712175](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210722211938.png)

##### 模板

```c
/* 
最小生成树 Kruskal算法
*/

#include <iostream>
#include <queue>
using namespace std;

#define MaxVertexNum 10
#define infinity 1e5
typedef int weightType;  // 权重数据类型
typedef char vertexType; // 顶点数据类型

// 最小堆里需要边的数据
struct MyEdge
{
    int v1;
    int v2;
    int weight;
};

// 优先队列排序函数
class mycomparison
{
public:
    bool operator()(const MyEdge &a, MyEdge &b)
    {
        return a.weight > b.weight;
    }
};

// 邻接表建立
struct EdgeNode
{
    int adjvex;
    weightType weight;
    EdgeNode *next;
};

struct VertexNode
{
    vertexType data;
    EdgeNode *firstedge;
};

struct Graph
{
    int vertexnum;
    int edgenum;
    VertexNode vertexList[MaxVertexNum];
};

void BuildGraph(Graph *G)
{
    int start, end, weight;
    EdgeNode *newnode;
    cout << "Please enter the number of vertices and edges" << endl;
    cin >> G->vertexnum >> G->edgenum;
    // 图的顶点数据
    for (int i = 1; i <= G->vertexnum; i++)
    {
        // 输入顶点名
        // cout << "Please enter the data of vertex" << i << endl;
        // cin >> G->vertexList[i].data;
        G->vertexList[i].firstedge = NULL;
    }
    // 输入权重信息
    for (int i = 1; i <= G->edgenum; i++)
    {
        cout << "Please enter the Start number, end number, weight" << endl;
        cin >> start >> end >> weight;
        //start-->end
        newnode = new EdgeNode;
        newnode->adjvex = end;
        newnode->weight = weight;
        newnode->next = G->vertexList[start].firstedge;
        G->vertexList[start].firstedge = newnode;
        // end-->start
        newnode = new EdgeNode;
        newnode->adjvex = start;
        newnode->weight = weight;
        newnode->next = G->vertexList[end].firstedge;
        G->vertexList[end].firstedge = newnode;
    }
    cout << endl;
}

// 并查集寻找根节点
int Find_set(int *parent, int x)
{
    for (; parent[x] != x; x = parent[x])
    {
        ;
    }
    return x;
}

// Kruskal算法
void Kruskal(Graph *G)
{
    // 初始化收录的边数
    int ECount = 0;
    // 初始化最小堆
    priority_queue<MyEdge, vector<MyEdge>, mycomparison> minheap;
    // 边入堆
    MyEdge N;
    for (int i = 1; i <= G->vertexnum; i++)
    {
        EdgeNode *p = G->vertexList[i].firstedge;
        // 无向图双向边是重复的，所以只收录一条，即v1小于v2的边
        while (p)
        {
            if (i < p->adjvex)
            {
                N.v1 = i;
                N.v2 = p->adjvex;
                N.weight = p->weight;
                // 入堆
                minheap.push(N);
            }
            p = p->next;
        }
    }
    // 初始化并查集
    int parent[G->vertexnum + 1];
    for (int i = 1; i <= G->vertexnum; i++)
    {
        // 每个子集的根节点设为自身
        parent[i] = i;
    }
    // 当收集到的边等于顶点数减一时，就可以构成生成树，要退出循环
    while (ECount < G->vertexnum - 1)
    {
        MyEdge tmp = minheap.top();
        minheap.pop();
        int root1 = Find_set(parent, tmp.v1);
        int root2 = Find_set(parent, tmp.v2);
        // 如果相等，说明二者属于同一集合，会构成回路
        if (root1 == root2)
        {
            continue;
        }
        // 输出选择的边
        cout << tmp.v1 << " " << tmp.v2 << endl;
        // 合并子集
        parent[root2] = root1;
        // 收录的边数加一
        ECount++;
    }
}

int main()
{
    Graph G;
    BuildGraph(&G);
    Kruskal(&G);
    cout << endl;
    system("pause");
    return 0;
}

/*  
6 10
1 2 6
1 4 5
1 3 1
2 3 5
3 4 5
3 5 6
3 6 4
5 6 6
2 5 3
4 6 2
*/
```

##### 复杂度

时间复杂度：$O(|E|\log|E|)$​，因此适合求解==稀疏图==的最小生成树。

### 5.5 拓扑排序

#### 5.5.1 AOV网

用有向边 $<V_i,V_j>$ 表示活动 $V_i$ 必须先于活动 $V_j$ 进行的这样一种关系，则将这种有向图称为顶点表示活动的网络，记为AOV网。在AOV网中，活动 $V_i$ 是活动 $V_j$ 的直接前驱，活动 $V_j$ 是活动 $V_i$ 的直接后继，这种前驱和后继关系具有传递性，且任何活动 $V_i$​​ 不能以它自己作为自己的前驱或后继。

#### 5.5.2 拓扑排序

##### 概念

- 每个顶点出现且只出现一次
- 若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径。

![image-20210723105457680](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210723105504.png)

##### 模板

```c
/* 
有向图邻接表实现拓扑排序
*/

#include <iostream>
#include <queue>
#include <vector>
using namespace std;

#define MaxVertexNum 10
typedef int weightType;  // 权重数据类型
typedef char vertexType; // 顶点数据类型

struct EdgeNode
{
    int adjvex;
    weightType weight;
    EdgeNode *next;
};

struct VertexNode
{
    vertexType data;
    EdgeNode *firstedge;
};

struct Graph
{
    int vertexnum;
    int edgenum;
    VertexNode vertexList[MaxVertexNum];
};

void BuildGraph(Graph *G)
{
    int start, end, weight;
    EdgeNode *newnode;
    cout << "Please enter the number of vertices and edges" << endl;
    cin >> G->vertexnum >> G->edgenum;
    // 图的顶点数据
    for (int i = 1; i <= G->vertexnum; i++)
    {
        // 输入顶点名
        // cout << "Please enter the data of vertex" << i << endl;
        // cin >> G->vertexList[i].data;
        G->vertexList[i].firstedge = NULL;
    }
    // 输入权重信息
    for (int i = 1; i <= G->edgenum; i++)
    {
        cout << "Please enter the Start number, end number" << endl;
        cin >> start >> end;
        //start-->end
        newnode = new EdgeNode;
        newnode->adjvex = end;
        // newnode->weight = weight;
        newnode->next = G->vertexList[start].firstedge;
        G->vertexList[start].firstedge = newnode;
    }
}

void TopologicalSort(Graph *G)
{
    // 初始化队列
    queue<int> q;
    // 初始化入度统计表
    vector<int> indegree(G->vertexnum + 1, 0);
    for (int i = 1; i <= G->vertexnum; i++)
    {
        for (EdgeNode *j = G->vertexList[i].firstedge; j; j = j->next)
        {
            indegree[j->adjvex]++;
        }
    }
    // 将所有入度为0的顶点入队
    for (int i = 1; i <= G->vertexnum; i++)
    {
        if (indegree[i] == 0)
        {
            q.push(i);
        }
    }
    // 输出的顶点数
    int count = 0;
    // 开始搜索
    while (count < G->vertexnum)
    {
        count++;
        int v = q.front();
        cout << v << "  ";
        q.pop();
        // 将v所指向的顶点入度减一
        for (EdgeNode *w = G->vertexList[v].firstedge; w; w = w->next)
        {
            if (--indegree[w->adjvex] == 0)
            {
                q.push(w->adjvex);
            }
        }
    }
}

int main()
{
    Graph G;
    BuildGraph(&G);
    TopologicalSort(&G);
    cout << endl;
    system("pause");
    return 0;
}

/*
8 10
1 2
1 3
2 3
3 8
3 7
7 8
5 3
4 5
5 6
6 7
*/
```

##### 复杂度

时间复杂度：$O(|V|+|E|)$​

#### 5.5.3 关键路径

##### 概念



##### 模板

```c

```



## 6. 排序

算法稳定性：若待排序表有两个元素 $R_i$ 和 $R_j$，其对应的关键字相同即 $key_i=key_j$，且排序前 $R_i$ 在 $R_j$ 前面。

- 若排序后 $R_i$​ 仍然在 $R_j$​​ 前面，则是稳定的。
- 反之亦然​ :facepunch:

### 6.1 直接插入排序

初始 $L[1]$ 可以视为已经排好的子序列，然后依次将 $L[2]-l[n]$ 插入已经排好的序列，共执行 $n-1$ 次操作。每次操作的具体步骤为从后往前依次和子序列元素比较，如果小于该元素往后移位，最后将自己插入适当的位置。 

```c
// 直接插入排序
void DirectInsertSort(ElementType A[], int n)
{
    int i, j;
    for (i = 2; i <= n; i++)
    {
        // 看是否比序列大，如果大就不用移动位置，反之要进入循环移动位置
        if (A[i] < A[i - 1])
        {
            // 放置哨兵
            A[0] = A[i];
            for (j = i - 1; A[j] > A[0]; j--)
            {
                // 向后移位
                A[j + 1] = A[j];
            }
            // 将哨兵里元素放到属于他的位置
            A[j + 1] = A[0];
        }
    }
}
```

空间复杂度：==$O(1)$==​​

时间复杂度：

- 最好情况：初始有序，每次插入元素就比较一次而不用移动元素，时间复杂度 $O(n)$
- 最坏情况：初始逆序，时间复杂度 $O(n^2)$
- 平均时间复杂度 ==$O(n^2)$​==

### 6.2 折半插入排序

查询元素位置用二分查找实现，但与二分查找不同，二分查找是查到元素的位置，但这里其实是通过左右比较，找到一个适当的位置，所以最后会以 $high=low-1$​ 结束，所以 $high$​ 指向元素就是应该插入元素的前一个元素。然后再统一向后移动元素。

```c
// 折半插入排序
void BinaryInsertSort(ElementType A[], int n)
{
    int i, j, mid, low, high;
    for (int i = 2; i <= n; i++)
    {
        A[0] = A[i];
        low = 1, high = i - 1;
        // 二分查找定位置
        while (low <= high)
        {
            mid = (low + high) / 2;
            if (A[mid] > A[0])
            {
                high = mid - 1;
            }
            else
            {
                low = mid + 1;
            }
        }
        // 最后会以high=low-1结束，所以high指向元素就是应该插入元素的前一个元素
        // 那么high+1表示的就是应该插入元素的位置
        for (j = i - 1; j >= high + 1; j--)
        {
            A[j + 1] = A[j];
        }
        A[high + 1] = A[0];
    }
}

```

空间复杂度：==$O(1)$==​​

时间复杂度：

- 仅减少了比较元素的次数，未改变移动次数，因此平均时间复杂度还是 ==$O(n^2)$​==

### 6.3 希尔排序

将相隔某一增量的元素组成子表，对每个子表直接插入排序。这个某一增量的取值一般为 $d_1=n/2，d_{i+1}=d_i/2$，到最后一个增量为1为止。相当于在元素**基本有序**时，对全体进行一次直接插入排序。

```c
// 希尔排序
void ShellSort(ElementType A[], int n)
{
    // 记录步长
    for (int dk = n / 2; dk >= 1; dk = dk / 2)
    {
        for (int i = dk + 1; i <= n; i++)
        {
            if (A[i] < A[i - dk])
            {
                A[0] = A[i];
                int j;
                for (j = i - dk; A[0] < A[j] && j > 0; j -= dk)
                {
                    A[j + dk] = A[j];
                }
                A[j + dk] = A[0];
            }
        }
    }
}
```

空间复杂度：==$O(1)$==​​

时间复杂度：

- 分析十分复杂，记住最优情况下约为 $O(n^{1.3})$​，最坏情况下 ==$O(n^2)$​​==

### 6.4 冒泡排序

从后往前**两两比较相邻元素的值**，若为逆序则交换。这是第一趟冒泡。结果是最小的元素到了第一个位置。下一趟冒泡，已经确定的最小元素不用参与，最多重复 $n-1$​ 趟冒泡就能把所有元素排好序。

```c
// 冒泡排序
void BubbleSort(ElementType A[], int n)
{
    for (int i = 0; i < n - 1; ++i)
    {
        // 判断本趟冒泡是否发生交换的标志
        bool flag = false;
        for (int j = n - 1; j > i; j--)
        {
            if (A[j - 1] > A[j])
            {
                swap(A[j - 1], A[j]);
                flag = true;
            }
        }
        if (!flag)
        {
            break;
        }
    }
}
```

空间复杂度：==$O(1)$==​​

时间复杂度：

- 最好情况：初始有序，只进行一次冒泡，时间复杂度 $O(n)$
- 最坏情况：初始逆序，需要 $n-1$ 次排序，时间复杂度 $O(n^2)$
- 平均时间复杂度 ==$O(n^2)$​==

### 6.5 :star:快速排序

任取一元素 $pivot$​​ 作为枢轴，一趟排序分成2部分，$pivot$​ 左边所有元素小于它，$pivot$​​ 右边所有元素大于​它。然后分别递归的对两个子表重复上述过程。直到每部分只有一个元素。

```c
// 快速排序
void QuickSort(ElementType A[], int low, int high)
{
    // 当子序列只剩一个元素时，pivot-1=low，这时high=low，函数结束
    if (low < high)
    {
        // 划分得到枢轴点位置
        int pivotpos = Partition(A, low, high);
        QuickSort(A, low, pivotpos - 1);
        QuickSort(A, pivotpos + 1, high);
    }
}

// 快速排序划分操作
int Partition(ElementType A[], int low, int high)
{
    // 选取第一个元素为枢轴点
    ElementType pivot = A[low];
    while (low < high)
    {
        // 循环找从右向左小于pivot的元素
        while (A[high] >= pivot && high > low)
        {
            high--;
        }
        // 找到该元素将该元素移到左端
        A[low] = A[high];
        while (A[low] <= pivot && high > low)
        {
            low++;
        }
        // 将比枢轴大的元素移到右端
        A[high] = A[low];
    }
    // 此时low=high，存放枢轴元素的值
    A[low] = pivot;
    return low;
}
```

空间复杂度：==$O(log_2n)$​==​​

时间复杂度：==$O(log_2n)$==

### 6.6 简单选择排序

就每次都选择序列中最小的元素，重复 $n-1$ 趟。

```c
// 简单选择排序
void SelectSort(ElementType A[], int n)
{
    for (int i = 0; i < n - 1; i++)
    {
        int j, min = i;
        for (j = i + 1; j < n; j++)
        {
            if (A[j] < A[min])
            {
                min = j;
            }
        }
        if (min != i)
        {
            swap(A[i], A[min]);
        }
    }
}
```

空间复杂度：==$O(1)$​==​​

时间复杂度：==$O(n^2)$==

### 6.7 :star:堆排序

根据堆的特性，最大堆堆顶元素就是最大值，输出堆顶元素后，将堆底元素放到堆顶，此时堆的性质被破坏，需要重新调整。

:question: 待解决问题？

- :one: 如何将无序序列构造成初始堆？
- :two: 输出堆顶元素后，如何调整堆？

对于 $n$ 个结点的完全二叉树，最后一个结点的父节点是 $n/2$，所以从 $n/2$ 为根结点的子树开始向前筛选，使子树成为堆。筛选方法：看结点是否大于左右子结点值，如小于，与左右子结点中较大者交换。交换后可能会破环下一级堆，于是继续调整。

```c
// 堆排序
void HeapSort(ElementType A[], int len)
{
    BuildMaxHeap(A, len);
    for (int i = len; i > 1; i--)
    {
        // 将根结点与末尾结点交换位置，那么最大元素就被移到数组最后面
        swap(A[i], A[1]);
        // 同时调整堆的时候只对前面i-1元素进行，这样影响不到后面的已排好元素
        HeadAdjust(A, 1, i - 1);
    }
}

// 建堆
void BuildMaxHeap(ElementType A[], int len)
{
    for (int i = len / 2; i > 0; i--)
    {
        HeadAdjust(A, i, len);
    }
}

// 调整堆
void HeadAdjust(ElementType A[], int k, int len)
{
    // A[0]暂时存放子树的根结点
    A[0] = A[k];
    for (int i = 2 * k; i <= len; i *= 2)
    {
        // i如果等于len则没有右子树，也就没有比较左右子树的必要了
        if (i < len && A[i] < A[i + 1])
        {
            i++;
        }
        if (A[i] <= A[0])
        {
            break;
        }
        else
        {
            // 将A[i]复制到父节点
            A[k] = A[i];
            // 修改k，用以定位子树根结点应该放置的位置
            k = i;
        }
    }
    A[k] = A[0];
}
```

空间复杂度：==$O(1)$​==​​

时间复杂度：==$O(nlog_2n)$==

### 6.8 :star:归并排序

待排序表有 $n$​​ 个记录，就看成 n 个有序的子表，每个子表长度为1，然后两两归并，得到 $n/2$ 个长度为2或者1个有序表，继续两两归并，直到合并成一个长度为 $n$ 的有序表为止。

```c
// 归并排序
void MergeSort(ElementType A[], int low, int high)
{
    // 划分子序列，分到每个子序列长度为1
    if (low < high)
    {
        int mid = (low + high) / 2;
        MergeSort(A, low, mid);
        MergeSort(A, mid + 1, high);
        Merge(A, low, mid, high);
    }
}

// 归并操作
void Merge(ElementType A[], int low, int mid, int high)
{
    int i = low;
    int j = mid + 1;
    int k;
    // 把子序列所有元素复制到B数组
    for (int k = low; k <= high; k++)
    {
        B[k] = A[k];
    }

    for (k = low; i <= mid && j <= high; k++)
    {
        // 两个子序列相互比较，当一个序列的元素被安置完后
        // 另外一个序列的剩余元素肯定是大于且有序的，直接顺序插入
        if (B[i] < B[j])
        {
            A[k] = B[i++];
        }
        else
        {
            A[k] = B[j++];
        }
    }
    // 如果第一个表没有检测完，复制
    while (i <= mid)
    {
        A[k++] = B[i++];
    }
    // 同理
    while (j <= high)
    {
        A[k++] = B[j++];
    }
    // 注：只有一个while会执行
}
```

空间复杂度：==$O(n)$​​​==​​

时间复杂度：==$O(nlog_2n)$==

### 6.9 基数排序

以关键字是1000一下的整数为例，基数 $r=10$，每个关键字由3个子关键字组成：$k^1K^2K^3$，分别代表百位，十位和个位，从次位开始（个位）依次进行操作。

次位优先基数排序过程：

- 分配

  ​	创建 $r=10$ 个空桶，按照每个元素的当前子关键字数值放置到不同的桶中

- 收集

  ​	把每个桶的结点首尾相连，形成一个新的线性表

```c
#include <iostream>
using namespace std;

struct node
{
    int data;
    node *next;
};

// 获得一个数的各个位上的数字
int GetDigit(int X, int D)
{
    // 默认次位D=1, 主位D<=MaxDigit
    int d, i;
    for (i = 1; i <= D; i++)
    {
        d = X % 10;
        X /= 10;
    }
    return d;
}

int main()
{
    // 基数
    int radix = 10;
    // 建立桶
    node *bucket[radix];
    // 初始化待排序数组
    int A[10] = {278, 109, 63, 930, 589, 184, 505, 269, 8, 83};
    node *list = NULL;
    node *p;
    for (int i = 0; i < 10; i++)
    {
        node *tmp = new node;
        tmp->data = A[i];
        tmp->next = NULL;
        if (list == NULL)
        {
            list = tmp;
            p = list;
        }
        else
        {
            p->next = tmp;
            p = p->next;
        }
    }
    // 开始排序，对每一位进行处理
    for (int i = 1; i <= 3; i++)
    {
        // 清空桶
        for (int i = 0; i < radix; i++)
        {
            bucket[i] = NULL;
        }
        p = list;
        node *tmp;
        // 分配
        while (p)
        {
            tmp = p;
            p = p->next;
            int k = GetDigit(tmp->data, i);
            if (bucket[k] == NULL)
            {
                bucket[k] = tmp;
            }
            else
            {
                node *q = bucket[k];
                while (q->next)
                {
                    q = q->next;
                }
                q->next = tmp;
            }
            tmp->next = NULL;
        }
        // 收集
        list = NULL;
        for (int j = 0; j < radix; j++)
        {
            if (bucket[j] == NULL)
            {
                continue;
            }
            // 链表首指针定位
            if (bucket[j] && list == NULL)
            {
                list = bucket[j];
                p = list;
                continue;
            }
            // 此时p任指向上一个存在的桶
            while (p->next)
            {
                p = p->next;
            }
            // 如现在的桶存在，让上一个桶的最后一个结点指过来
            p->next = bucket[j];
        }
        // 打印
        cout << i << " trip: ";
        p = list;
        while (p)
        {
            cout << p->data << " ";
            p = p->next;
        }
        cout << endl;
    }
    system("pause");
    return 0;
}
```

$r$ 为桶个数，d为子关键字个数（趟数），$n$ 为元素个数

空间复杂度：==$O(r)$​​​​​==​​

时间复杂度：==$O(d(n+r))$==

### 6.10 :star_and_crescent:总结

![image-20210730224003651](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210730224010.png)

## 7. 查找

