# 操作系统实验

## 作者寄语

操作系统实验的学习是一个循序渐进的过程，初次看linux-0.11中的代码，看着满屏的汇编语言，确实头疼。但通过学习赵炯博士的Linux内核0.11完全注释，结合着王爽老师的汇编语言一书，我逐渐理解每段汇编语言的含义和作用。本文主要是通过对哈工大李治军配套实验的实现，着重解释每一段的汇编代码，使读者对实验的整体脉络有一个初步的认识，不再因为畏惧汇编而不放弃实验。本文只是抛砖引玉，希望读者可以深入研究我下文提供的参考资料，做到理论与实践兼具。

## 参考资料

- [视频:操作系统](https://www.bilibili.com/video/BV1d4411v7u7?p=3&spm_id_from=pageDriver)
- [书籍:现代操作系统](file:///D:/为中华之崛起而读书/计算机书籍/现代操作系统（原书第3版） (计算机科学丛书).pdf)
- [实验:操作系统原理与实践](https://www.lanqiao.cn/courses/115)
- [书籍:王道操作系统](file:///D:/为中华之崛起而读书/考研/王道/2022王道操作系统.pdf)
- [书籍:Linux内核完全注释](file:///D:/为中华之崛起而读书/计算机书籍/Linux内核完全注释.pdf)
- [书籍:汇编语言(第3版) 王爽著](file:///D:/为中华之崛起而读书/计算机书籍/《汇编语言(第3版) 》王爽著.pdf)

## 目录

[TOC]

## 实验1 熟悉实验环境

只是熟悉实验环境，我没有使用蓝桥云课的实验环境，而是通过阿里云服务器搭建了linux环境，有需要的可以看以下2篇文章

- [阿里云服务器Ubuntu14.04（64位）安装图形化界面_leoabcd12的博客-CSDN博客](https://blog.csdn.net/leoabcd12/article/details/118751547)
- [阿里云ubuntu系统配置linux-0.11（哈工大 李治军）实验环境搭建_leoabcd12的博客-CSDN博客](https://blog.csdn.net/leoabcd12/article/details/118755040)

## 实验2 操作系统的引导

Linux 0.11 文件夹中的 `boot/bootsect.s`、`boot/setup.s` 和 `tools/build.c` 是本实验会涉及到的源文件。它们的功能详见《Linux内核0.11完全注释》的 6.2、6.3 节和 16 章。

### 汇编知识

简要整理了一下这次实验所需的基础汇编知识，可以在下文阅读代码是碰到再回过头来看！

#### int 0x10

![image-20210808151038949](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210814222256.png)

注意，这里ah要先有值，代表内部子程序的编号

功能号 $ah=0x03$​​​，作用是读取光标的位置

- 输入：bh = 页号
- 返回：ch = 扫描开始线；cl = 扫描结束线；dh = 行号；dl = 列号

功能号 $ah=0x13$，作用是显示字符串

- 输入：al = 放置光标的方式及规定属性，下文 al＝1，表示目标字符串仅仅包含字符，属性在BL中包含，光标停在字符串结尾处；es:bp = 字符串起始位置；cx = 显示的字符串字符数；bh = 页号；bl = 字符属性，下文 bl = 07H，表示正常的黑底白字；dh = 行号；dl = 列号

功能号 $ah=0x0e$​，作用是显示字符

- 输入：al = 字符

#### int 0x13

在DOS等实模式操作系统下，调用INT 13h会跳转到计算机的ROM-BIOS代码中进行低级磁盘服务，对程序进行基于物理扇区的磁盘读写操作。

功能号 $ah=0x02$，作用是读磁盘扇区到内存

- 输入：

  | 寄存器 |        含义        |
  | :----: | :----------------: |
  |   ah   |  读磁盘扇区到内存  |
  |   al   | 需要读出的扇区数量 |
  |   ch   |        磁道        |
  |   cl   |        扇区        |
  |   dh   |        磁头        |
  |   dl   |       驱动器       |
  | es:bx  |  数据缓冲区的地址  |

- 返回：ah = 出错码（00H表示无错，01H表示非法命令，02H表示地址目标未发现...）；CF为进位标志位，如果没有出错 $CF=0$​

功能号 $ah=0x00$​，作用是磁盘系统复位

- 输入：dl = 驱动器
- 返回：如果操作成功———— $CF=0$​​，$ah=00H$​​

这里我只挑了下文需要的介绍，更多内容可以参考这篇博客[BIOS系统服务 —— 直接磁盘服务（int 0x13）](https://blog.csdn.net/cherisegege/article/details/79835737)

#### int 0x15

功能号 $ah=0x88$，作用是获取系统所含扩展内存大小

- 输入：ah = 0x88
- 返回：ax = 从0x100000(1M)处开始的拓展内存大小(KB)。若出错则CF置位，ax = 出错码。

#### int 0x41

在PC机中BIOS设定的中断向量表中`int 0x41`的中断向量位置         ($4*0x41 = 0x0000:0x0104$​​​)存放的并不是中断程序的地址,而是第一个硬盘的基本参数表。对于100%兼容的BIOS来说,这里存放着硬盘参数表阵列的首地址0xF000:0E401，第二个硬盘的基本参数表入口地址存于`int 0x46`中断向量位置处.每个硬盘参数表有16个字节大小.

| 位移 | 大小 |     说明     |
| :--: | :--: | :----------: |
| 0x00 |  字  |    柱面数    |
| 0x02 | 字节 |    磁头数    |
| ...  | ...  |     ...      |
| 0x0E | 字节 | 每磁道扇区数 |
| 0x0F | 字节 |     保留     |

#### CF

要了解CF，首先要知道寄存器中有一种特殊的寄存器————标志寄存器，其中存储的信息通常被称为程序状态字。以下简称为flag寄存器。

flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。

![image-20210810220308173](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210814222330.png)

flag的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义。而0、2、4、6、7、8、9、10、11位都具有特殊的含义。

CF就是flag的第0位————进位标志位。在进行==无符号数==运算的时候，它记录了运算结果的最高有效位向更高位的==进位值==，或从更高位的借位值。

#### jnc

在 $CF=0$​​​ 的时候，进行跳转，即不进位则跳转，下文就是在读入没有出错时，跳转到ok_load_setup

#### jl

小于则跳转

#### lds

格式： LDS reg16，mem32

其意义是同时给一个段寄存器和一个16位通用寄存器同时赋值

举例：

| 地址 | 100H | 101H | 102H | 103H |
| :--: | :--: | :--: | :--: | :--: |
| 内容 | 00H  | 41H  | 02H  | 03H  |

```sh
LDS AX,[100H]
! 结果：AX=4100H  DS=0302H
```

可以把上述代码理解为这样一个过程，但实际上不能这么写

```sh
mov AX,[100H]
mov DS,[100H+2]
```

即把低字(2B)置为偏移地址，高字(2B)置为段地址

#### DF标志和串传送指令

flag的第10位是DF,方向标志位。在串处理指令中，控制每次操作后si、di的增减。

- df=0：每次操作后si、di递增
- df=1：每次操作后si、di递减

来看一个串传送指令

- 格式：movsb

- 功能：相当于执行了如下2步操作
  
  1. $((es)*16+(di))=((ds)*16+si)$
  
  2. 如果df=0：(si)=(si)+1,(di)=(di)+1
  
     如果df=1：(si)=(si)-1,(di)=(di)-1

可以看出，movsb的功能是将 $ds:si$ 指向的内存单元中的字节送入 $es:di$中，然后根据标志寄存器df位的值，将si和di递增或递减。

也可以传送一个字

- 格式：movsw

- 功能：相当于执行了如下2步操作

  1. $((es)*16+(di))=((ds)*16+si)$

  2. 如果df=0：(si)=(si)+2,(di)=(di)+2

     如果df=1：(si)=(si)-2,(di)=(di)-2

可以看出，movsw的功能是将 $ds:si$ 指向的内存单元中的字节送入 $es:di$​中，然后根据标志寄存器df位的值， 将si和di递增2或递减2。

movsb和movsw进行的是串传送操作的一个步骤，一般配合rep使用

格式如下：rep movsb

用汇编语法描述：

```ba
s:movsb
 loop s
```

可见rep的作用是根据cx的值，重复执行串传送指令。由于每执行一次movsb指令si和di都会递增或递减指向后面一个单元或前面一个单元，则 rep movsb就可以循环实现(cx)个字符的传送。

#### call

(1) 将当前IP或CS和IP压入栈中

(2) 转移

CPU执行“call 标号”时，相当于进行：

```sh
push IP
jmp near ptr 标号
```

#### ret

ret指令用栈中的数据，修改IP的内容，从而实现近转移

(1) $(IP)=((ss)*16+(sp))$

(2) $(sp)=(sp)+2$​

CPU执行ret指令时，相当于进行：

```sh
pop IP
```

### 改写bootsect.s

打开 `bootsect.s`

![image-20210711135216130](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210814222620.png)

![image-20210814222810462](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210814222810.png)

`Loading system ...`就是开机时显示在屏幕上的字，共16字符，加上3个换行+回车，一共是24字符。我将要修改他为` Hello OS world, my name is WCF`，30字符，加上3个换行+回车，共36字符。所以图一代码修改为`mov cx.#36`。

将 `.org 508` 修改为 `.org 510`，是因为这里不需要 `root_dev: .word ROOT_DEV`，为了保证 `boot_flag` 一定在引导扇区最后两个字节，所以要修改 `.org`。`.org 510` 表示下面语句从地址510(0x1FE)开始，用来强制要求`boot_flag`一定在引导扇区的最后2个字节中（第511和512字节）。

完整的代码如下：

```sh
entry _start
_start:
    mov ah,#0x03        ! 设置功能号
    xor bh,bh           ! 将bh置0
    int 0x10            ! 返回行号和列号，供显示串用
    mov cx,#52          ！要显示的字符串长度
    mov bx,#0x0007      ! bh=0,bl=07(正常的黑底白字)
    mov bp,#msg1        ! es:bp 要显示的字符串物理地址
    mov ax,#0x07c0      ! 将es段寄存器置为#0x07c0
    mov es,ax           
    mov ax,#0x1301      ! ah=13(设置功能号),al=01(目标字符串仅仅包含字符，属性在BL中包含，光标停在字符串结尾处)
    int 0x10            ! 显示字符串

! 设置一个无限循环(纯粹为了能一直看到字符串显示)
inf_loop:
    jmp inf_loop

! 字符串信息
msg1:
    .byte   13,10           ! 换行+回车
    .ascii  "Welcome to the world without assembly language"
    .byte   13,10,13,10     ! 换行+回车

! 将
.org 510

! 启动盘具有有效引导扇区的标志。仅供BIOS中的程序加载引导扇区时识别使用。它必须位于引导扇区的最后两个字节中
boot_flag:
    .word   0xAA55
```

Ubuntu 上先从终端进入 ~/oslab/linux-0.11/boot/目录

执行下面两个命令编译和链接 `bootsect.s`：

```
$ as86 -0 -a -o bootsect.o bootsect.s
$ ld86 -0 -s -o bootsect bootsect.o
```

![image-20210711112503976](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210711112504.png)

其中 `bootsect.o` 是中间文件。`bootsect` 是编译、链接后的目标文件。

需要留意的文件是 `bootsect` 的文件大小是 544 字节，而引导程序必须要正好占用一个磁盘扇区，即 512 个字节。造成多了 32 个字节的原因是 ld86 产生的是 Minix 可执行文件格式，这样的可执行文件处理文本段、数据段等部分以外，还包括一个 Minix 可执行文件头部，它的结构如下：

```c
struct exec {
    unsigned char a_magic[2];  //执行文件魔数
    unsigned char a_flags;
    unsigned char a_cpu;       //CPU标识号
    unsigned char a_hdrlen;    //头部长度，32字节或48字节
    unsigned char a_unused;
    unsigned short a_version;
    long a_text; long a_data; long a_bss; //代码段长度、数据段长度、堆长度
    long a_entry;    //执行入口地址
    long a_total;    //分配的内存总量
    long a_syms;     //符号表大小
};
```

6 char（6 字节）+ 1 short（2 字节） + 6 long（24 字节）= 32，正好是 32 个字节，去掉这 32 个字节后就可以放入引导扇区了。

对于上面的 Minix 可执行文件，其 a_magic[0]=0x01，a_magic[1]=0x03，a_flags=0x10（可执行文件），a_cpu=0x04（表示 Intel i8086/8088，如果是 0x17 则表示 Sun 公司的 SPARC），所以 `bootsect` 文件的头几个字节应该是 01 03 10 04。为了验证一下，Ubuntu 下用命令`hexdump -C bootsect`可以看到：

![image-20210814222824190](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210814222824.png)

去掉这 32 个字节的文件头部

```
$ dd bs=1 if=bootsect of=Image skip=32
```

生成的 Image 就是去掉文件头的 `bootsect`。

去掉这 32 个字节后，将生成的文件拷贝到 linux-0.11 目录下，并一定要命名为“Image”（注意大小写）。然后就“run”吧！

```
# 当前的工作路径为 /oslab/linux-0.11/boot/
# 将刚刚生成的 Image 复制到 linux-0.11 目录下
$ cp ./Image ../Image
# 执行 oslab 目录中的 run 脚本
$ ../../run
```

![image-20210814222834302](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210814222834.png)

### bootsect.s读入setup.s

首先编写一个 setup.s，该 setup.s 可以就直接拷贝前面的 bootsect.s（还需要简单的调整），然后将其中的显示的信息改为：“Now we are in SETUP”。

和前面基本一样，就不注释了。

```sh
entry _start
_start:
	mov ah,#0x03
	xor bh,bh
	int 0x10
	mov cx,#25
	mov bx,#0x0007
	mov bp,#msg2
	mov ax,cs				! 这里的cs其实就是这段代码的段地址
	mov es,ax
	mov ax,#0x1301
	int 0x10
inf_loop:
	jmp inf_loop
msg2:
	.byte	13,10
	.ascii	"Now we are in SETUP"
	.byte	13,10,13,10
.org 510
boot_flag:
	.word	0xAA55
```

接下来需要编写 `bootsect.s` 中载入 `setup.s` 的关键代码

所有需要的功能在原版 `bootsect.s` 中都是存在的，我们要做的仅仅是将这些代码添加到新的 `bootsect.s` 中去。

除了新增代码，我们还需要去掉在 `bootsect.s` 添加的无限循环。

```sh
SETUOLEN=2              ! 读入的扇区数
SETUPSEG=0x07e0         ! setup代码的段地址
entry _start
_start:
    mov ah,#0x03        ! 设置功能号
    xor bh,bh           ! 将bh置0
    int 0x10            ! 返回行号和列号，供显示串用
    mov cx,#52          ！要显示的字符串长度
    mov bx,#0x0007      ! bh=0,bl=07(正常的黑底白字)
    mov bp,#msg1        ! es:bp 要显示的字符串物理地址
    mov ax,#0x07c0      ! 将es段寄存器置为#0x07c0
    mov es,ax           
    mov ax,#0x1301      ! ah=13(设置功能号),al=01(目标字符串仅仅包含字符，属性在BL中包含，光标停在字符串结尾处)
    int 0x10            ! 显示字符串

! 将setup模块从磁盘的第二个扇区开始读到0x7e00
load_setup:
    mov dx,#0x0000                  ! 磁头=0；驱动器号=0
    mov cx,#0x0002                  ! 磁道=0；扇区=2
    mov bx,#0x0200                  ! 偏移地址
    mov ax,#0x0200+SETUPLEN         ! 设置功能号；需要读出的扇区数量
    int 0x13                        ! 读磁盘扇区到内存
    jnc ok_load_setup               ! CF=0(读入成功)跳转到ok_load_setup  
    mov dx,#0x0000                  ! 如果读入失败，使用功能号ah=0x00————磁盘系统复位
    mov ax,#0x0000
    int 0x13
    jmp load_setup                  ! 尝试重新读入

ok_load_setup:
    jmpi    0,SETUPSEG              ! 段间跳转指令，跳转到setup模块处(0x07e0:0000)

! 字符串信息
msg1:
    .byte   13,10           ! 换行+回车
    .ascii  "Welcome to the world without assembly language"
    .byte   13,10,13,10     ! 换行+回车

! 将
.org 510

! 启动盘具有有效引导扇区的标志。仅供BIOS中的程序加载引导扇区时识别使用。它必须位于引导扇区的最后两个字节中
boot_flag:
    .word   0xAA55
```

再次编译

```
$ make BootImage
```

有 Error！这是因为 make 根据 Makefile 的指引执行了 `tools/build.c`，它是为生成整个内核的镜像文件而设计的，没考虑我们只需要 `bootsect.s` 和 `setup.s` 的情况。它在向我们要 “系统” 的核心代码。为完成实验，接下来给它打个小补丁。c

`build.c` 从命令行参数得到 bootsect、setup 和 system 内核的文件名，将三者做简单的整理后一起写入 Image。其中 system 是第三个参数（argv[3]）。当 “make all” 或者 “makeall” 的时候，这个参数传过来的是正确的文件名，`build.c` 会打开它，将内容写入 Image。而 “make BootImage” 时，传过来的是字符串 "none"。所以，改造 build.c 的思路就是当 argv[3] 是"none"的时候，只写 bootsect 和 setup，忽略所有与 system 有关的工作，或者在该写 system 的位置都写上 “0”。

修改工作主要集中在 `build.c` 的尾部，可长度以参考下面的方式，将圈起来的部分注释掉。

![image-20210814222844903](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210814222844.png)

重新编译

```sh
$ cd ~/oslab/linux-0.11
$ make BootImage
$ ../run
```

![image-20210814222851074](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210814222851.png)

### setup.s获取基本硬件参数

 这里把一些难以理解的代码单独列出来

1. 获得磁盘参数

这里花了我很长时间，原因是概念没有搞清楚，我觉得老师在实验指导书上写的也不是很清楚，CSDN上都只是草草复制的代码，感觉他们可以压根没有理解这一段。

先来回顾一下上文的一个概念：`int 0x41`

在PC机中BIOS设定的中断向量表中`int 0x41`的中断向量位置         ($4*0x41 = 0x0000:0x0104$​)存放的并不是中断程序的地址,而是第一个硬盘的基本参数表。对于100%兼容的BIOS来说,==这里存放着硬盘参数表阵列的首地址0xF000:0E401==，第二个硬盘的基本参数表入口地址存于`int 0x46`中断向量位置处.每个硬盘参数表有16个字节大小.

这段话是重点，我之前误理解为磁盘参数就存放在以0x0000:0x0104为首地址的单元中，总共占16个字节，但实际上，只存了4个字节，里面存放的是磁盘参数表的偏移地址和段地址，也就是上文所说==这里存放着硬盘参数表阵列的首地址0xF000:0E401==。

```sh
lds    si,[4*0x41]
```

再看这行代码就可以理解了，这里是把0x0000:0x0104单元存放的值（表示硬盘参数表阵列的首地址的偏移地址）赋给si寄存器，把0x0000:0x0106单元存放的值（表示硬盘参数表阵列的首地址的段地址）赋给ds寄存器。

2. 参数以十六进制方式显示

先说说浪费我很长时间的我的错误：我想的是一个ASCII码8位，为什么答案里是4位4位输出，这里是搞清楚显示的目的。显示的是存在内存单元里的16进制数，例如某个字(2个字节)中的数值为 $019A$​，我所要显示的不是01和9A表示的ASCII码，而是显示019A本身，所以要4位4位显示。

以十六进制方式显示比较简单。这是因为十六进制与二进制有很好的对应关系（每 4 位二进制数和 1 位十六进制数存在一一对应关系），显示时只需将原二进制数每 4 位划成一组，按组求对应的 ASCII 码送显示器即可。ASCII 码与十六进制数字的对应关系为：0x30 ～ 0x39 对应数字 0 ～ 9，0x41 ～ 0x46 对应数字 a ～ f。从数字 9 到 a，其 ASCII 码间隔了 7h，这一点在转换时要特别注意。为使一个十六进制数能按高位到低位依次显示，实际编程中，需对 bx 中的数每次循环左移一组（4 位二进制），然后屏蔽掉当前高 12 位，对当前余下的 4 位（即 1 位十六进制数）求其 ASCII 码，要判断它是 0 ～ 9 还是 a ～ f，是前者则加 0x30 得对应的 ASCII 码，后者则要加 0x37 才行，最后送显示器输出。以上步骤重复 4 次，就可以完成 bx 中数以 4 位十六进制的形式显示出来。

下面是提供的参考代码

```sh
INITSEG  = 0x9000                   ! 参数存放位置的段地址
entry _start
_start:
! 打印 "NOW we are in SETUP"
    mov ah,#0x03
    xor bh,bh
    int 0x10
    mov cx,#25
    mov bx,#0x0007
    mov bp,#msg2
    mov ax,cs
    mov es,ax
    mov ax,#0x1301
    int 0x10

! 获取光标位置
    mov ax,#INITSEG
    mov ds,ax
    mov ah,#0x03
    xor bh,bh
    int 0x10                        ! 返回：dh = 行号；dl = 列号
    mov [0],dx                      ! 存储到内存0x9000:0处

! 获取内存大小
    mov ah,#0x88
    int 0x15                        ! 返回：ax = 从0x100000(1M)处开始的扩展内存大小(KB)
    mov [2],ax                      ! 将扩展内存数值存放在0x90002处（1个字）

! 读第一个磁盘参数表复制到0x90004处
    mov ax,#0x0000
    mov ds,ax
    lds si,[4*0x41]                 ! 把低字(2B)置为偏移地址，高字(2B)置为段地址
    mov ax,#INITSEG
    mov es,ax
    mov di,#0x0004
    mov cx,#0x10                    ! 重复16次，即传送16B
    rep
    movsb                           ! 按字节传送

! 打印前的准备
    mov ax,cs
    mov es,ax
    mov ax,#INITSEG
    mov ds,ax

! 打印"Cursor position:"
    mov ah,#0x03
    xor bh,bh
    int 0x10
    mov cx,#18
    mov bx,#0x0007
    mov bp,#msg_cursor
    mov ax,#0x1301
    int 0x10

! 打印光标位置
    mov dx,[0]
    call    print_hex

! 打印"Memory Size:"
    mov ah,#0x03
    xor bh,bh
    int 0x10
    mov cx,#14
    mov bx,#0x0007
    mov bp,#msg_memory
    mov ax,#0x1301
    int 0x10

! 打印内存大小
    mov dx,[2]
    call    print_hex

! 打印"KB"
    mov ah,#0x03
    xor bh,bh
    int 0x10
    mov cx,#2
    mov bx,#0x0007
    mov bp,#msg_kb
    mov ax,#0x1301
    int 0x10

! 打印"Cyls:" 
    mov ah,#0x03
    xor bh,bh
    int 0x10
    mov cx,#7
    mov bx,#0x0007
    mov bp,#msg_cyles
    mov ax,#0x1301
    int 0x10

! 打印柱面数   
    mov dx,[4]
    call    print_hex

! 打印"Heads:"
    mov ah,#0x03
    xor bh,bh
    int 0x10
    mov cx,#8
    mov bx,#0x0007
    mov bp,#msg_heads
    mov ax,#0x1301
    int 0x10

! 打印磁头数
    mov dx,[6]
    call    print_hex

! 打印"Sectors:"
    mov ah,#0x03
    xor bh,bh
    int 0x10
    mov cx,#10
    mov bx,#0x0007
    mov bp,#msg_sectors
    mov ax,#0x1301
    int 0x10
    mov dx,[18]
    call    print_hex

inf_loop:
    jmp inf_loop

! 上面的call都转到这里
print_hex:
    mov    cx,#4                    ! dx(16位)可以显示4个十六进制数字
print_digit:
    rol    dx,#4                    ! 取 dx 的高4比特移到低4比特处
    mov    ax,#0xe0f                ! ah = 请求的功能值(显示单个字符)，al = 半字节(4个比特)掩码
    and    al,dl                    ! 前4位会被置为0
    add    al,#0x30                 ! 给 al 数字加上十六进制 0x30
    cmp    al,#0x3a                 ! 比较看是否大于数字十
    jl     outp                     ! 是一个不大于十的数字则跳转
    add    al,#0x07                 ! 否则就是a~f，要多加7
outp:
    int    0x10                     ! 显示单个字符
    loop   print_digit              ! 重复4次
    ret                             

! 打印换行回车
print_nl:
    mov    ax,#0xe0d     ! CR
    int    0x10
    mov    al,#0xa     ! LF
    int    0x10
    ret

msg2:
    .byte 13,10
    .ascii "NOW we are in SETUP"
    .byte 13,10,13,10
msg_cursor:
    .byte 13,10
    .ascii "Cursor position:"
msg_memory:
    .byte 13,10
    .ascii "Memory Size:"
msg_cyles:
    .byte 13,10
    .ascii "Cyls:"
msg_heads:
    .byte 13,10
    .ascii "Heads:"
msg_sectors:
    .byte 13,10
    .ascii "Sectors:"
msg_kb:
    .ascii "KB"

.org 510
boot_flag:
    .word 0xAA55
```

经过漫长的调试，得到如下结果

![image-20210814222905927](C:/Users/王超凡/Desktop/20210814222906.png)

Memory Size 是 0x3C00KB，算一算刚好是 15MB（扩展内存），加上 1MB 正好是 16MB，看看 Bochs 配置文件 bochs/bochsrc.bxrc：

![image-20210814222912950](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210814222913.png)

这些都和上面打出的参数吻合，表示此次实验是成功的。

### 天道酬勤

实验二总共花费25小时，因为没有汇编基础，花费了大量时间在理解代码上，希望下面的实验可以越做越快吧。
