# 操作系统实验

## 作者寄语

操作系统实验的学习是一个循序渐进的过程，初次看linux-0.11中的代码，看着满屏的汇编语言，确实头疼。但通过学习赵炯博士的Linux内核0.11完全注释，结合着王爽老师的汇编语言一书，我逐渐理解每段汇编语言的含义和作用。本文主要是通过对哈工大李治军配套实验的实现，着重解释每一段的汇编代码，使读者对实验的整体脉络有一个初步的认识，不再因为畏惧汇编而不放弃实验。本文只是抛砖引玉，希望读者可以深入研究我下文提供的参考资料，做到理论与实践兼具。

## 参考资料

- [视频:操作系统](https://www.bilibili.com/video/BV1d4411v7u7?p=3&spm_id_from=pageDriver)
- [书籍:现代操作系统](file:///D:/为中华之崛起而读书/计算机书籍/现代操作系统（原书第3版） (计算机科学丛书).pdf)
- [实验:操作系统原理与实践](https://www.lanqiao.cn/courses/115)
- [书籍:王道操作系统](file:///D:/为中华之崛起而读书/考研/王道/2022王道操作系统.pdf)
- [书籍:Linux内核完全注释](file:///D:/为中华之崛起而读书/计算机书籍/Linux内核完全注释.pdf)
- [书籍:汇编语言(第3版) 王爽著](file:///D:/为中华之崛起而读书/计算机书籍/《汇编语言(第3版) 》王爽著.pdf)

## 目录

[TOC]

## 实验1 熟悉实验环境

只是熟悉实验环境，我没有使用蓝桥云课的实验环境，而是通过阿里云服务器搭建了linux环境，有需要的可以看以下2篇文章

- [阿里云服务器Ubuntu14.04（64位）安装图形化界面_leoabcd12的博客-CSDN博客](https://blog.csdn.net/leoabcd12/article/details/118751547)
- [阿里云ubuntu系统配置linux-0.11（哈工大 李治军）实验环境搭建_leoabcd12的博客-CSDN博客](https://blog.csdn.net/leoabcd12/article/details/118755040)

## 实验2 操作系统的引导

Linux 0.11 文件夹中的 `boot/bootsect.s`、`boot/setup.s` 和 `tools/build.c` 是本实验会涉及到的源文件。它们的功能详见《Linux内核0.11完全注释》的 6.2、6.3 节和 16 章。

### 汇编知识

简要整理了一下这次实验所需的基础汇编知识，可以在下文阅读代码是碰到再回过头来看！

#### int 0x10

![image-20210808151038949](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210814222256.png)

注意，这里ah要先有值，代表内部子程序的编号

功能号 $ah=0x03$​​​，作用是读取光标的位置

- 输入：bh = 页号
- 返回：ch = 扫描开始线；cl = 扫描结束线；dh = 行号；dl = 列号

功能号 $ah=0x13$，作用是显示字符串

- 输入：al = 放置光标的方式及规定属性，下文 al＝1，表示目标字符串仅仅包含字符，属性在BL中包含，光标停在字符串结尾处；es:bp = 字符串起始位置；cx = 显示的字符串字符数；bh = 页号；bl = 字符属性，下文 bl = 07H，表示正常的黑底白字；dh = 行号；dl = 列号

功能号 $ah=0x0e$​，作用是显示字符

- 输入：al = 字符

#### int 0x13

在DOS等实模式操作系统下，调用INT 13h会跳转到计算机的ROM-BIOS代码中进行低级磁盘服务，对程序进行基于物理扇区的磁盘读写操作。

功能号 $ah=0x02$，作用是读磁盘扇区到内存

- 输入：

  | 寄存器 |        含义        |
  | :----: | :----------------: |
  |   ah   |  读磁盘扇区到内存  |
  |   al   | 需要读出的扇区数量 |
  |   ch   |        磁道        |
  |   cl   |        扇区        |
  |   dh   |        磁头        |
  |   dl   |       驱动器       |
  | es:bx  |  数据缓冲区的地址  |

- 返回：ah = 出错码（00H表示无错，01H表示非法命令，02H表示地址目标未发现...）；CF为进位标志位，如果没有出错 $CF=0$​

功能号 $ah=0x00$​，作用是磁盘系统复位

- 输入：dl = 驱动器
- 返回：如果操作成功———— $CF=0$​​，$ah=00H$​​

这里我只挑了下文需要的介绍，更多内容可以参考这篇博客[BIOS系统服务 —— 直接磁盘服务（int 0x13）](https://blog.csdn.net/cherisegege/article/details/79835737)

#### int 0x15

功能号 $ah=0x88$，作用是获取系统所含扩展内存大小

- 输入：ah = 0x88
- 返回：ax = 从0x100000(1M)处开始的拓展内存大小(KB)。若出错则CF置位，ax = 出错码。

#### int 0x41

在PC机中BIOS设定的中断向量表中`int 0x41`的中断向量位置         ($4*0x41 = 0x0000:0x0104$​​​)存放的并不是中断程序的地址,而是第一个硬盘的基本参数表。对于100%兼容的BIOS来说,这里存放着硬盘参数表阵列的首地址0xF000:0E401，第二个硬盘的基本参数表入口地址存于`int 0x46`中断向量位置处.每个硬盘参数表有16个字节大小.

| 位移 | 大小 |     说明     |
| :--: | :--: | :----------: |
| 0x00 |  字  |    柱面数    |
| 0x02 | 字节 |    磁头数    |
| ...  | ...  |     ...      |
| 0x0E | 字节 | 每磁道扇区数 |
| 0x0F | 字节 |     保留     |

#### CF

要了解CF，首先要知道寄存器中有一种特殊的寄存器————标志寄存器，其中存储的信息通常被称为程序状态字。以下简称为flag寄存器。

flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。

![image-20210810220308173](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210814222330.png)

flag的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义。而0、2、4、6、7、8、9、10、11位都具有特殊的含义。

CF就是flag的第0位————进位标志位。在进行==无符号数==运算的时候，它记录了运算结果的最高有效位向更高位的==进位值==，或从更高位的借位值。

#### jnc

在 $CF=0$​​​ 的时候，进行跳转，即不进位则跳转，下文就是在读入没有出错时，跳转到ok_load_setup

#### jl

小于则跳转

#### lds

格式： LDS reg16，mem32

其意义是同时给一个段寄存器和一个16位通用寄存器同时赋值

举例：

| 地址 | 100H | 101H | 102H | 103H |
| :--: | :--: | :--: | :--: | :--: |
| 内容 | 00H  | 41H  | 02H  | 03H  |

```sh
LDS AX,[100H]
! 结果：AX=4100H  DS=0302H
```

可以把上述代码理解为这样一个过程，但实际上不能这么写

```sh
mov AX,[100H]
mov DS,[100H+2]
```

即把低字(2B)置为偏移地址，高字(2B)置为段地址

#### DF标志和串传送指令

flag的第10位是DF,方向标志位。在串处理指令中，控制每次操作后si、di的增减。

- df=0：每次操作后si、di递增
- df=1：每次操作后si、di递减

来看一个串传送指令

- 格式：movsb

- 功能：相当于执行了如下2步操作
  
  1. $((es)*16+(di))=((ds)*16+si)$
  
  2. 如果df=0：(si)=(si)+1,(di)=(di)+1
  
     如果df=1：(si)=(si)-1,(di)=(di)-1

可以看出，movsb的功能是将 $ds:si$ 指向的内存单元中的字节送入 $es:di$中，然后根据标志寄存器df位的值，将si和di递增或递减。

也可以传送一个字

- 格式：movsw

- 功能：相当于执行了如下2步操作

  1. $((es)*16+(di))=((ds)*16+si)$

  2. 如果df=0：(si)=(si)+2,(di)=(di)+2

     如果df=1：(si)=(si)-2,(di)=(di)-2

可以看出，movsw的功能是将 $ds:si$ 指向的内存单元中的字节送入 $es:di$​中，然后根据标志寄存器df位的值， 将si和di递增2或递减2。

movsb和movsw进行的是串传送操作的一个步骤，一般配合rep使用

格式如下：rep movsb

用汇编语法描述：

```ba
s:movsb
 loop s
```

可见rep的作用是根据cx的值，重复执行串传送指令。由于每执行一次movsb指令si和di都会递增或递减指向后面一个单元或前面一个单元，则 rep movsb就可以循环实现(cx)个字符的传送。

#### call

(1) 将当前IP或CS和IP压入栈中

(2) 转移

CPU执行“call 标号”时，相当于进行：

```sh
push IP
jmp near ptr 标号
```

#### ret

ret指令用栈中的数据，修改IP的内容，从而实现近转移

(1) $(IP)=((ss)*16+(sp))$

(2) $(sp)=(sp)+2$​

CPU执行ret指令时，相当于进行：

```sh
pop IP
```

### 改写bootsect.s

打开 `bootsect.s`

![image-20210711135216130](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210814222620.png)

![image-20210814222810462](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210814222810.png)

`Loading system ...`就是开机时显示在屏幕上的字，共16字符，加上3个换行+回车，一共是24字符。我将要修改他为` Hello OS world, my name is WCF`，30字符，加上3个换行+回车，共36字符。所以图一代码修改为`mov cx.#36`。

将 `.org 508` 修改为 `.org 510`，是因为这里不需要 `root_dev: .word ROOT_DEV`，为了保证 `boot_flag` 一定在引导扇区最后两个字节，所以要修改 `.org`。`.org 510` 表示下面语句从地址510(0x1FE)开始，用来强制要求`boot_flag`一定在引导扇区的最后2个字节中（第511和512字节）。

完整的代码如下：

```sh
entry _start
_start:
    mov ah,#0x03        ! 设置功能号
    xor bh,bh           ! 将bh置0
    int 0x10            ! 返回行号和列号，供显示串用
    mov cx,#52          ！要显示的字符串长度
    mov bx,#0x0007      ! bh=0,bl=07(正常的黑底白字)
    mov bp,#msg1        ! es:bp 要显示的字符串物理地址
    mov ax,#0x07c0      ! 将es段寄存器置为#0x07c0
    mov es,ax           
    mov ax,#0x1301      ! ah=13(设置功能号),al=01(目标字符串仅仅包含字符，属性在BL中包含，光标停在字符串结尾处)
    int 0x10            ! 显示字符串

! 设置一个无限循环(纯粹为了能一直看到字符串显示)
inf_loop:
    jmp inf_loop

! 字符串信息
msg1:
    .byte   13,10           ! 换行+回车
    .ascii  "Welcome to the world without assembly language"
    .byte   13,10,13,10     ! 换行+回车

! 将
.org 510

! 启动盘具有有效引导扇区的标志。仅供BIOS中的程序加载引导扇区时识别使用。它必须位于引导扇区的最后两个字节中
boot_flag:
    .word   0xAA55
```

Ubuntu 上先从终端进入 ~/oslab/linux-0.11/boot/目录

执行下面两个命令编译和链接 `bootsect.s`：

```
$ as86 -0 -a -o bootsect.o bootsect.s
$ ld86 -0 -s -o bootsect bootsect.o
```

![image-20210711112503976](https://raw.githubusercontent.com/Casten-Wang/Pic/master/20210711112504.png)

其中 `bootsect.o` 是中间文件。`bootsect` 是编译、链接后的目标文件。

需要留意的文件是 `bootsect` 的文件大小是 544 字节，而引导程序必须要正好占用一个磁盘扇区，即 512 个字节。造成多了 32 个字节的原因是 ld86 产生的是 Minix 可执行文件格式，这样的可执行文件处理文本段、数据段等部分以外，还包括一个 Minix 可执行文件头部，它的结构如下：

```c
struct exec {
    unsigned char a_magic[2];  //执行文件魔数
    unsigned char a_flags;
    unsigned char a_cpu;       //CPU标识号
    unsigned char a_hdrlen;    //头部长度，32字节或48字节
    unsigned char a_unused;
    unsigned short a_version;
    long a_text; long a_data; long a_bss; //代码段长度、数据段长度、堆长度
    long a_entry;    //执行入口地址
    long a_total;    //分配的内存总量
    long a_syms;     //符号表大小
};
```

6 char（6 字节）+ 1 short（2 字节） + 6 long（24 字节）= 32，正好是 32 个字节，去掉这 32 个字节后就可以放入引导扇区了。

对于上面的 Minix 可执行文件，其 a_magic[0]=0x01，a_magic[1]=0x03，a_flags=0x10（可执行文件），a_cpu=0x04（表示 Intel i8086/8088，如果是 0x17 则表示 Sun 公司的 SPARC），所以 `bootsect` 文件的头几个字节应该是 01 03 10 04。为了验证一下，Ubuntu 下用命令`hexdump -C bootsect`可以看到：

![image-20210814222824190](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210814222824.png)

去掉这 32 个字节的文件头部

```
$ dd bs=1 if=bootsect of=Image skip=32
```

生成的 Image 就是去掉文件头的 `bootsect`。

去掉这 32 个字节后，将生成的文件拷贝到 linux-0.11 目录下，并一定要命名为“Image”（注意大小写）。然后就“run”吧！

```
# 当前的工作路径为 /oslab/linux-0.11/boot/
# 将刚刚生成的 Image 复制到 linux-0.11 目录下
$ cp ./Image ../Image
# 执行 oslab 目录中的 run 脚本
$ ../../run
```

![image-20210814222834302](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210814222834.png)

### bootsect.s读入setup.s

首先编写一个 setup.s，该 setup.s 可以就直接拷贝前面的 bootsect.s（还需要简单的调整），然后将其中的显示的信息改为：“Now we are in SETUP”。

和前面基本一样，就不注释了。

```sh
entry _start
_start:
	mov ah,#0x03
	xor bh,bh
	int 0x10
	mov cx,#25
	mov bx,#0x0007
	mov bp,#msg2
	mov ax,cs				! 这里的cs其实就是这段代码的段地址
	mov es,ax
	mov ax,#0x1301
	int 0x10
inf_loop:
	jmp inf_loop
msg2:
	.byte	13,10
	.ascii	"Now we are in SETUP"
	.byte	13,10,13,10
.org 510
boot_flag:
	.word	0xAA55
```

接下来需要编写 `bootsect.s` 中载入 `setup.s` 的关键代码

所有需要的功能在原版 `bootsect.s` 中都是存在的，我们要做的仅仅是将这些代码添加到新的 `bootsect.s` 中去。

除了新增代码，我们还需要去掉在 `bootsect.s` 添加的无限循环。

```sh
SETUOLEN=2              ! 读入的扇区数
SETUPSEG=0x07e0         ! setup代码的段地址
entry _start
_start:
    mov ah,#0x03        ! 设置功能号
    xor bh,bh           ! 将bh置0
    int 0x10            ! 返回行号和列号，供显示串用
    mov cx,#52          ！要显示的字符串长度
    mov bx,#0x0007      ! bh=0,bl=07(正常的黑底白字)
    mov bp,#msg1        ! es:bp 要显示的字符串物理地址
    mov ax,#0x07c0      ! 将es段寄存器置为#0x07c0
    mov es,ax           
    mov ax,#0x1301      ! ah=13(设置功能号),al=01(目标字符串仅仅包含字符，属性在BL中包含，光标停在字符串结尾处)
    int 0x10            ! 显示字符串

! 将setup模块从磁盘的第二个扇区开始读到0x7e00
load_setup:
    mov dx,#0x0000                  ! 磁头=0；驱动器号=0
    mov cx,#0x0002                  ! 磁道=0；扇区=2
    mov bx,#0x0200                  ! 偏移地址
    mov ax,#0x0200+SETUPLEN         ! 设置功能号；需要读出的扇区数量
    int 0x13                        ! 读磁盘扇区到内存
    jnc ok_load_setup               ! CF=0(读入成功)跳转到ok_load_setup  
    mov dx,#0x0000                  ! 如果读入失败，使用功能号ah=0x00————磁盘系统复位
    mov ax,#0x0000
    int 0x13
    jmp load_setup                  ! 尝试重新读入

ok_load_setup:
    jmpi    0,SETUPSEG              ! 段间跳转指令，跳转到setup模块处(0x07e0:0000)

! 字符串信息
msg1:
    .byte   13,10           ! 换行+回车
    .ascii  "Welcome to the world without assembly language"
    .byte   13,10,13,10     ! 换行+回车

! 将
.org 510

! 启动盘具有有效引导扇区的标志。仅供BIOS中的程序加载引导扇区时识别使用。它必须位于引导扇区的最后两个字节中
boot_flag:
    .word   0xAA55
```

再次编译

```
$ make BootImage
```

有 Error！这是因为 make 根据 Makefile 的指引执行了 `tools/build.c`，它是为生成整个内核的镜像文件而设计的，没考虑我们只需要 `bootsect.s` 和 `setup.s` 的情况。它在向我们要 “系统” 的核心代码。为完成实验，接下来给它打个小补丁。c

`build.c` 从命令行参数得到 bootsect、setup 和 system 内核的文件名，将三者做简单的整理后一起写入 Image。其中 system 是第三个参数（argv[3]）。当 “make all” 或者 “makeall” 的时候，这个参数传过来的是正确的文件名，`build.c` 会打开它，将内容写入 Image。而 “make BootImage” 时，传过来的是字符串 "none"。所以，改造 build.c 的思路就是当 argv[3] 是"none"的时候，只写 bootsect 和 setup，忽略所有与 system 有关的工作，或者在该写 system 的位置都写上 “0”。

修改工作主要集中在 `build.c` 的尾部，可长度以参考下面的方式，将圈起来的部分注释掉。

![image-20210814222844903](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210814222844.png)

重新编译

```sh
$ cd ~/oslab/linux-0.11
$ make BootImage
$ ../run
```

![image-20210814222851074](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210814222851.png)

### setup.s获取基本硬件参数

 这里把一些难以理解的代码单独列出来

1. 获得磁盘参数

这里花了我很长时间，原因是概念没有搞清楚，我觉得老师在实验指导书上写的也不是很清楚，CSDN上都只是草草复制的代码，感觉他们可以压根没有理解这一段。

先来回顾一下上文的一个概念：`int 0x41`

在PC机中BIOS设定的中断向量表中`int 0x41`的中断向量位置         ($4*0x41 = 0x0000:0x0104$​)存放的并不是中断程序的地址,而是第一个硬盘的基本参数表。对于100%兼容的BIOS来说,==这里存放着硬盘参数表阵列的首地址0xF000:0E401==，第二个硬盘的基本参数表入口地址存于`int 0x46`中断向量位置处.每个硬盘参数表有16个字节大小.

这段话是重点，我之前误理解为磁盘参数就存放在以0x0000:0x0104为首地址的单元中，总共占16个字节，但实际上，只存了4个字节，里面存放的是磁盘参数表的偏移地址和段地址，也就是上文所说==这里存放着硬盘参数表阵列的首地址0xF000:0E401==。

```sh
lds    si,[4*0x41]
```

再看这行代码就可以理解了，这里是把0x0000:0x0104单元存放的值（表示硬盘参数表阵列的首地址的偏移地址）赋给si寄存器，把0x0000:0x0106单元存放的值（表示硬盘参数表阵列的首地址的段地址）赋给ds寄存器。

2. 参数以十六进制方式显示

先说说浪费我很长时间的我的错误：我想的是一个ASCII码8位，为什么答案里是4位4位输出，这里是搞清楚显示的目的。显示的是存在内存单元里的16进制数，例如某个字(2个字节)中的数值为 $019A$​，我所要显示的不是01和9A表示的ASCII码，而是显示019A本身，所以要4位4位显示。

以十六进制方式显示比较简单。这是因为十六进制与二进制有很好的对应关系（每 4 位二进制数和 1 位十六进制数存在一一对应关系），显示时只需将原二进制数每 4 位划成一组，按组求对应的 ASCII 码送显示器即可。ASCII 码与十六进制数字的对应关系为：0x30 ～ 0x39 对应数字 0 ～ 9，0x41 ～ 0x46 对应数字 a ～ f。从数字 9 到 a，其 ASCII 码间隔了 7h，这一点在转换时要特别注意。为使一个十六进制数能按高位到低位依次显示，实际编程中，需对 bx 中的数每次循环左移一组（4 位二进制），然后屏蔽掉当前高 12 位，对当前余下的 4 位（即 1 位十六进制数）求其 ASCII 码，要判断它是 0 ～ 9 还是 a ～ f，是前者则加 0x30 得对应的 ASCII 码，后者则要加 0x37 才行，最后送显示器输出。以上步骤重复 4 次，就可以完成 bx 中数以 4 位十六进制的形式显示出来。

下面是提供的参考代码

```sh
INITSEG  = 0x9000                   ! 参数存放位置的段地址
entry _start
_start:
! 打印 "NOW we are in SETUP"
    mov ah,#0x03
    xor bh,bh
    int 0x10
    mov cx,#25
    mov bx,#0x0007
    mov bp,#msg2
    mov ax,cs
    mov es,ax
    mov ax,#0x1301
    int 0x10

! 获取光标位置
    mov ax,#INITSEG
    mov ds,ax
    mov ah,#0x03
    xor bh,bh
    int 0x10                        ! 返回：dh = 行号；dl = 列号
    mov [0],dx                      ! 存储到内存0x9000:0处

! 获取内存大小
    mov ah,#0x88
    int 0x15                        ! 返回：ax = 从0x100000(1M)处开始的扩展内存大小(KB)
    mov [2],ax                      ! 将扩展内存数值存放在0x90002处（1个字）

! 读第一个磁盘参数表复制到0x90004处
    mov ax,#0x0000
    mov ds,ax
    lds si,[4*0x41]                 ! 把低字(2B)置为偏移地址，高字(2B)置为段地址
    mov ax,#INITSEG
    mov es,ax
    mov di,#0x0004
    mov cx,#0x10                    ! 重复16次，即传送16B
    rep
    movsb                           ! 按字节传送

! 打印前的准备
    mov ax,cs
    mov es,ax
    mov ax,#INITSEG
    mov ds,ax

! 打印"Cursor position:"
    mov ah,#0x03
    xor bh,bh
    int 0x10
    mov cx,#18
    mov bx,#0x0007
    mov bp,#msg_cursor
    mov ax,#0x1301
    int 0x10

! 打印光标位置
    mov dx,[0]
    call    print_hex

! 打印"Memory Size:"
    mov ah,#0x03
    xor bh,bh
    int 0x10
    mov cx,#14
    mov bx,#0x0007
    mov bp,#msg_memory
    mov ax,#0x1301
    int 0x10

! 打印内存大小
    mov dx,[2]
    call    print_hex

! 打印"KB"
    mov ah,#0x03
    xor bh,bh
    int 0x10
    mov cx,#2
    mov bx,#0x0007
    mov bp,#msg_kb
    mov ax,#0x1301
    int 0x10

! 打印"Cyls:" 
    mov ah,#0x03
    xor bh,bh
    int 0x10
    mov cx,#7
    mov bx,#0x0007
    mov bp,#msg_cyles
    mov ax,#0x1301
    int 0x10

! 打印柱面数   
    mov dx,[4]
    call    print_hex

! 打印"Heads:"
    mov ah,#0x03
    xor bh,bh
    int 0x10
    mov cx,#8
    mov bx,#0x0007
    mov bp,#msg_heads
    mov ax,#0x1301
    int 0x10

! 打印磁头数
    mov dx,[6]
    call    print_hex

! 打印"Sectors:"
    mov ah,#0x03
    xor bh,bh
    int 0x10
    mov cx,#10
    mov bx,#0x0007
    mov bp,#msg_sectors
    mov ax,#0x1301
    int 0x10
    mov dx,[18]
    call    print_hex

inf_loop:
    jmp inf_loop

! 上面的call都转到这里
print_hex:
    mov    cx,#4                    ! dx(16位)可以显示4个十六进制数字
print_digit:
    rol    dx,#4                    ! 取 dx 的高4比特移到低4比特处
    mov    ax,#0xe0f                ! ah = 请求的功能值(显示单个字符)，al = 半字节(4个比特)掩码
    and    al,dl                    ! 前4位会被置为0
    add    al,#0x30                 ! 给 al 数字加上十六进制 0x30
    cmp    al,#0x3a                 ! 比较看是否大于数字十
    jl     outp                     ! 是一个不大于十的数字则跳转
    add    al,#0x07                 ! 否则就是a~f，要多加7
outp:
    int    0x10                     ! 显示单个字符
    loop   print_digit              ! 重复4次
    ret                             

! 打印换行回车
print_nl:
    mov    ax,#0xe0d     ! CR
    int    0x10
    mov    al,#0xa     ! LF
    int    0x10
    ret

msg2:
    .byte 13,10
    .ascii "NOW we are in SETUP"
    .byte 13,10,13,10
msg_cursor:
    .byte 13,10
    .ascii "Cursor position:"
msg_memory:
    .byte 13,10
    .ascii "Memory Size:"
msg_cyles:
    .byte 13,10
    .ascii "Cyls:"
msg_heads:
    .byte 13,10
    .ascii "Heads:"
msg_sectors:
    .byte 13,10
    .ascii "Sectors:"
msg_kb:
    .ascii "KB"

.org 510
boot_flag:
    .word 0xAA55
```

经过漫长的调试，得到如下结果

![image-20210814222905927](C:/Users/王超凡/Desktop/20210814222906.png)

Memory Size 是 0x3C00KB，算一算刚好是 15MB（扩展内存），加上 1MB 正好是 16MB，看看 Bochs 配置文件 bochs/bochsrc.bxrc：

![image-20210814222912950](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210814222913.png)

这些都和上面打出的参数吻合，表示此次实验是成功的。

### 天道酬勤

实验二总共花费25小时，因为没有汇编基础，花费了大量时间在理解代码上，希望下面的实验可以越做越快吧。

## 实验3 系统调用

### 提醒

这次实验涉及的宏过于复杂，加上本人能力有限，我也没有花大量时间去研究每一段代码，只是理解到每一段代码做了什么这一程度。

### 实验目的

此次实验的基本内容是：在 Linux 0.11 上添加两个系统调用，并编写两个简单的应用程序测试它们。

1. iam()

   第一个系统调用是 iam()，其原型为：

   ```c
   int iam(const char * name);
   ```

   完成的功能是将字符串参数 `name` 的内容拷贝到内核中保存下来。要求 `name` 的长度不能超过 23 个字符。返回值是拷贝的字符数。如果 `name` 的字符个数超过了 23，则返回 “-1”，并置 errno 为 EINVAL。

2. whoami()

   第二个系统调用是 whoami()，其原型为：

   ```c
   int whoami(char* name, unsigned int size);
   ```

   它将内核中由 `iam()` 保存的名字拷贝到 name 指向的用户地址空间中，同时确保不会对 `name` 越界访存（`name` 的大小由 `size` 说明）。返回值是拷贝的字符数。如果 `size` 小于需要的空间，则返回“-1”，并置 errno 为 EINVAL。

### 应用程序如何调用系统调用

在通常情况下，调用系统调用和调用一个普通的自定义函数在代码上并没有什么区别，但调用后发生的事情有很大不同。

调用自定义函数是通过 call 指令直接跳转到该函数的地址，继续运行。

而调用系统调用，是调用系统库中为该系统调用编写的一个接口函数，叫 API（Application Programming Interface）。API 并不能完成系统调用的真正功能，它要做的是去调用真正的系统调用，过程是：

- 把系统调用的编号存入 EAX；
- 把函数参数存入其它通用寄存器；
- 触发 0x80 号中断（int 0x80）。

linux-0.11 的 lib 目录下有一些已经实现的 API。Linus 编写它们的原因是在内核加载完毕后，会切换到用户模式下，做一些初始化工作，然后启动 shell。而用户模式下的很多工作需要依赖一些系统调用才能完成，因此在内核中实现了这些系统调用的 API。

我们不妨看看 lib/close.c，研究一下 `close()` 的 API：

```c
#define __LIBRARY__
#include <unistd.h>

_syscall1(int, close, int, fd)
```

其中 `_syscall1` 是一个宏，在 `include/unistd.h` 中定义。

```c
#define _syscall1(type,name,atype,a) \
type name(atype a) \
{ \
long __res; \
__asm__ volatile ("int $0x80" \
    : "=a" (__res) \
    : "0" (__NR_##name),"b" ((long)(a))); \
if (__res >= 0) \
    return (type) __res; \
errno = -__res; \
return -1; \
}
```

将 `_syscall1(int,close,int,fd)` 进行宏展开，可以得到：

```c
int close(int fd)
{
    long __res;
    __asm__ volatile ("int $0x80"
        : "=a" (__res)
        : "0" (__NR_close),"b" ((long)(fd)));
    if (__res >= 0)
        return (int) __res;
    errno = -__res;
    return -1;
}
```

这就是 API 的定义。它先将宏 `__NR_close` 存入 EAX，将参数 fd 存入 EBX，然后进行 0x80 中断调用。调用返回后，从 EAX 取出返回值，存入 `__res`，再通过对 `__res` 的判断决定传给 API 的调用者什么样的返回值。

其中 `__NR_close` 就是系统调用的编号，在 `include/unistd.h` 中定义：

```c
#define __NR_close    6
/*
所以添加系统调用时需要修改include/unistd.h文件，
使其包含__NR_whoami和__NR_iam。
*/
```

```c
/*
而在应用程序中，要有：
*/

/* 有它，_syscall1 等才有效。详见unistd.h */
#define __LIBRARY__

/* 有它，编译器才能获知自定义的系统调用的编号 */
#include "unistd.h"

/* iam()在用户空间的接口函数 */
_syscall1(int, iam, const char*, name);

/* whoami()在用户空间的接口函数 */
_syscall2(int, whoami,char*,name,unsigned int,size);
```

在 0.11 环境下编译 C 程序，包含的头文件都在 `/usr/include` 目录下。

该目录下的 `unistd.h` 是标准头文件（它和 0.11 源码树中的 `unistd.h` 并不是同一个文件，虽然内容可能相同），没有 `__NR_whoami` 和 `__NR_iam` 两个宏，需要手工加上它们，也可以直接从修改过的 0.11 源码树中拷贝新的 unistd.h 过来。

### 从“int 0x80”进入内核函数

`int 0x80` 触发后，接下来就是内核的中断处理了。先了解一下 0.11 处理 0x80 号中断的过程。

在内核初始化时，主函数在 `init/main.c` 中，调用了 `sched_init()` 初始化函数：

```c
void main(void)
{
//    ……
    time_init();
    sched_init();
    buffer_init(buffer_memory_end);
//    ……
}
```

`sched_init()` 在 `kernel/sched.c` 中定义为：

```c
void sched_init(void)
{
//    ……
    set_system_gate(0x80,&system_call);
}
```

`set_system_gate` 是个宏，在 `include/asm/system.h` 中定义为：

```c
#define set_system_gate(n,addr) \
    _set_gate(&idt[n],15,3,addr)
```

`_set_gate` 的定义是：

```c
#define _set_gate(gate_addr,type,dpl,addr) \
__asm__ ("movw %%dx,%%ax\n\t" \
    "movw %0,%%dx\n\t" \
    "movl %%eax,%1\n\t" \
    "movl %%edx,%2" \
    : \
    : "i" ((short) (0x8000+(dpl<<13)+(type<<8))), \
    "o" (*((char *) (gate_addr))), \
    "o" (*(4+(char *) (gate_addr))), \
    "d" ((char *) (addr)),"a" (0x00080000))
```

虽然看起来挺麻烦，但实际上很简单，就是填写 IDT（中断描述符表），将 `system_call` 函数地址写到 `0x80` 对应的中断描述符中，也就是在中断 `0x80` 发生后，自动调用函数 `system_call`。

接下来看 `system_call`。该函数纯汇编打造，定义在 `kernel/system_call.s` 中：

```bash
!……
! # 这是系统调用总数。如果增删了系统调用，必须做相应修改
nr_system_calls = 72
!……

.globl system_call
.align 2
system_call:

! # 检查系统调用编号是否在合法范围内
    cmpl \$nr_system_calls-1,%eax
    ja bad_sys_call
    push %ds
    push %es
    push %fs
    pushl %edx
    pushl %ecx

! # push %ebx,%ecx,%edx，是传递给系统调用的参数
    pushl %ebx

! # 让ds, es指向GDT，内核地址空间
    movl $0x10,%edx
    mov %dx,%ds
    mov %dx,%es
    movl $0x17,%edx
! # 让fs指向LDT，用户地址空间
    mov %dx,%fs
    call sys_call_table(,%eax,4)
    pushl %eax
    movl current,%eax
    cmpl $0,state(%eax)
    jne reschedule
    cmpl $0,counter(%eax)
    je reschedule
```

`system_call` 用 `.globl` 修饰为其他函数可见。

`call sys_call_table(,%eax,4)` 之前是一些压栈保护，修改段选择子为内核段，`call sys_call_table(,%eax,4)` 之后是看看是否需要重新调度，这些都与本实验没有直接关系，此处只关心 `call sys_call_table(,%eax,4)` 这一句。

根据汇编寻址方法它实际上是：`call sys_call_table + 4 * %eax`，其中 eax 中放的是系统调用号，即 `__NR_xxxxxx`。

显然，`sys_call_table` 一定是一个函数指针数组的起始地址，它定义在 `include/linux/sys.h` 中：

```
fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read,...
```

增加实验要求的系统调用，需要在这个函数表中增加两个函数引用 ——`sys_iam` 和 `sys_whoami`。当然该函数在 `sys_call_table` 数组中的位置必须和 `__NR_xxxxxx` 的值对应上。

同时还要仿照此文件中前面各个系统调用的写法，加上：

```c
extern int sys_whoami();
extern int sys_iam();
```

不然，编译会出错的。

### 实现 sys_iam() 和 sys_whoami()

添加系统调用的最后一步，是在内核中实现函数 `sys_iam()` 和 `sys_whoami()`。

每个系统调用都有一个 `sys_xxxxxx()` 与之对应，它们都是我们学习和模仿的好对象。

比如在 `fs/open.c` 中的 `sys_close(int fd)`：

```c
int sys_close(unsigned int fd)
{
//    ……
    return (0);
}
```

它没有什么特别的，都是实实在在地做 `close()` 该做的事情。

所以只要自己创建一个文件：`kernel/who.c`，然后实现两个函数就万事大吉了。

### 按照上述逻辑修改相应文件

通过上文描述，我们已经理清楚了要修改的地方在哪里

1. 添加iam和whoami系统调用编号的宏定义(_NR_xxxxxx)，文件：**include/unistd.h**

   ![image-20210829143749907](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210829143757.png)

2. 修改系统调用总数, 文件：**kernel/system_call.s**

   ![image-20210829144114522](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210829144114.png)

3. 为新增的系统调用添加系统调用名并维护系统调用表，文件：**include/linux/sys.h**

   ![image-20210829144844784](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210829144844.png)

4. 为新增的系统调用编写代码实现，在**linux-0.11/kernel**目录下，创建一个文件 `who.c`

   ```c
   #include <asm/segment.h>
   #include <errno.h>
   #include <string.h>
   
   char _myname[24];
   
   int sys_iam(const char *name)
   {
       char str[25];
       int i = 0;
   
       do
       {
           // get char from user input
           str[i] = get_fs_byte(name + i);
       } while (i <= 25 && str[i++] != '\0');
   
       if (i > 24)
       {
           errno = EINVAL;
           i = -1;
       }
       else
       {
           // copy from user mode to kernel mode
           strcpy(_myname, str);
       }
   
       return i;
   }
   
   int sys_whoami(char *name, unsigned int size)
   {
       int length = strlen(_myname);
       printk("%s\n", _myname);
   
       if (size < length)
       {
           errno = EINVAL;
           length = -1;
       }
       else
       {
           int i = 0;
           for (i = 0; i < length; i++)
           {
               // copy from kernel mode to user mode
               put_fs_byte(_myname[i], name + i);
           }
       }
       return length;
   }
   ```

### 修改 Makefile

要想让我们添加的 `kernel/who.c` 可以和其它 Linux 代码编译链接到一起，必须要修改 Makefile 文件。

Makefile 里记录的是所有源程序文件的编译、链接规则，《注释》3.6 节有简略介绍。我们之所以简单地运行 make 就可以编译整个代码树，是因为 make 完全按照 Makefile 里的指示工作。

Makefile 在代码树中有很多，分别负责不同模块的编译工作。我们要修改的是 `kernel/Makefile`。需要修改两处。

#### （1）第一处

```makefile
OBJS  = sched.o system_call.o traps.o asm.o fork.o \
        panic.o printk.o vsprintf.o sys.o exit.o \
        signal.o mktime.o
```

改为：

```makefile
OBJS  = sched.o system_call.o traps.o asm.o fork.o \
        panic.o printk.o vsprintf.o sys.o exit.o \
        signal.o mktime.o who.o
```

添加了 `who.o`。

![image-20210829161702940](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210829161703.png)

#### （2）第二处

```makefile
### Dependencies:
exit.s exit.o: exit.c ../include/errno.h ../include/signal.h \
  ../include/sys/types.h ../include/sys/wait.h ../include/linux/sched.h \
  ../include/linux/head.h ../include/linux/fs.h ../include/linux/mm.h \
  ../include/linux/kernel.h ../include/linux/tty.h ../include/termios.h \
  ../include/asm/segment.h
```

改为：

```makefile
### Dependencies:
who.s who.o: who.c ../include/linux/kernel.h ../include/unistd.h
exit.s exit.o: exit.c ../include/errno.h ../include/signal.h \
  ../include/sys/types.h ../include/sys/wait.h ../include/linux/sched.h \
  ../include/linux/head.h ../include/linux/fs.h ../include/linux/mm.h \
  ../include/linux/kernel.h ../include/linux/tty.h ../include/termios.h \
  ../include/asm/segment.h
```

添加了 `who.s who.o: who.c ../include/linux/kernel.h ../include/unistd.h`。

![image-20210829162022371](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210829162022.png)

Makefile 修改后，和往常一样 `make all` 就能自动把 `who.c` 加入到内核中了。

### 编写测试程序

到此为止，内核中需要修改的部分已经完成，接下来需要编写测试程序来验证新增的系统调用是否已经被编译到linux-0.11内核可供调用。首先在oslab目录下编写iam.c，whoami.c

```c
/* iam.c */
#define __LIBRARY__
#include <unistd.h> 
#include <errno.h>
#include <asm/segment.h> 
#include <linux/kernel.h>
_syscall1(int, iam, const char*, name);
   
int main(int argc, char *argv[])
{
    /*调用系统调用iam()*/
    iam(argv[1]);
    return 0;
}
```

```c
/* whoami.c */
#define __LIBRARY__
#include <unistd.h> 
#include <errno.h>
#include <asm/segment.h> 
#include <linux/kernel.h>
#include <stdio.h>
   
_syscall2(int, whoami,char *,name,unsigned int,size);
   
int main(int argc, char *argv[])
{
    char username[64] = {0};
    /*调用系统调用whoami()*/
    whoami(username, 24);
    printf("%s\n", username);
    return 0;
}
```

以上两个文件需要放到启动后的linux-0.11操作系统上运行，验证新增的系统调用是否有效，那如何才能将这两个文件从宿主机转到稍后虚拟机中启动的linux-0.11操作系统上呢？这里我们采用挂载方式实现宿主机与虚拟机操作系统的文件共享，在 `oslab` 目录下执行以下命令挂载hdc目录到虚拟机操作系统上。

```Shell
sudo ./mount-hdc 
```

再通过以下命令将上述两个文件拷贝到虚拟机linux-0.11操作系统/usr/root/目录下，命令在oslab/目录下执行：

```Shell
cp iam.c whoami.c hdc/usr/root
```

如果目标目录下存在对应的两个文件则可启动虚拟机进行测试了。

- 编译

  ```shell
  [/usr/root]# gcc -o iam iam.c
  [/usr/root]# gcc -o whoami whoami.c
  ```

- 运行测试

  ```shell
  [/usr/root]# ./iam wcf
  [/usr/root]# ./whoami
  ```

命令执行后，很可能会报以下错误：

![image-20210829172115712](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210829172115.png)

这代表==虚拟机==操作系统中/usr/include/unistd.h文件中没有新增的系统调用调用号

为新增系统调用设置调用号

```c
#define __NR_whoami	   	72
#define __NR_iam	   	73     
```

再次执行：

![image-20210829215630491](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210829215630.png)

实验成功

------



- 为什么这里会打印2次？

- 因为在系统内核中执行了 `printk()` 函数，在用户模式下又执行了一次 `printf()` 函数。

要知道到，printf() 是一个只能在用户模式下执行的函数，而系统调用是在内核模式中运行，所以 printf() 不可用，要用 printk()。

`printk()` 和 `printf()` 的接口和功能基本相同，只是代码上有一点点不同。printk() 需要特别处理一下 `fs` 寄存器，它是专用于用户模式的段寄存器。

![image-20210829220203825](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210829220203.png)

![image-20210829220217721](https://casten.oss-cn-shanghai.aliyuncs.com/img/20210829220217.png)

### 天道酬勤

实验三总共花费7小时，看的不是特别仔细，没有特别深入的学习宏展开和内联汇编。但基本理解了系统调用的目的和方式，Linus永远的神！
